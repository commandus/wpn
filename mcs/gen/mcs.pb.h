// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mcs.proto

#ifndef PROTOBUF_mcs_2eproto__INCLUDED
#define PROTOBUF_mcs_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)

namespace protobuf_mcs_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[17];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void InitDefaultsHeartbeatPingImpl();
void InitDefaultsHeartbeatPing();
void InitDefaultsHeartbeatAckImpl();
void InitDefaultsHeartbeatAck();
void InitDefaultsErrorInfoImpl();
void InitDefaultsErrorInfo();
void InitDefaultsSettingImpl();
void InitDefaultsSetting();
void InitDefaultsHeartbeatStatImpl();
void InitDefaultsHeartbeatStat();
void InitDefaultsHeartbeatConfigImpl();
void InitDefaultsHeartbeatConfig();
void InitDefaultsClientEventImpl();
void InitDefaultsClientEvent();
void InitDefaultsLoginRequestImpl();
void InitDefaultsLoginRequest();
void InitDefaultsLoginResponseImpl();
void InitDefaultsLoginResponse();
void InitDefaultsStreamErrorStanzaImpl();
void InitDefaultsStreamErrorStanza();
void InitDefaultsCloseImpl();
void InitDefaultsClose();
void InitDefaultsExtensionImpl();
void InitDefaultsExtension();
void InitDefaultsIqStanzaImpl();
void InitDefaultsIqStanza();
void InitDefaultsAppDataImpl();
void InitDefaultsAppData();
void InitDefaultsDataMessageStanzaImpl();
void InitDefaultsDataMessageStanza();
void InitDefaultsStreamAckImpl();
void InitDefaultsStreamAck();
void InitDefaultsSelectiveAckImpl();
void InitDefaultsSelectiveAck();
inline void InitDefaults() {
  InitDefaultsHeartbeatPing();
  InitDefaultsHeartbeatAck();
  InitDefaultsErrorInfo();
  InitDefaultsSetting();
  InitDefaultsHeartbeatStat();
  InitDefaultsHeartbeatConfig();
  InitDefaultsClientEvent();
  InitDefaultsLoginRequest();
  InitDefaultsLoginResponse();
  InitDefaultsStreamErrorStanza();
  InitDefaultsClose();
  InitDefaultsExtension();
  InitDefaultsIqStanza();
  InitDefaultsAppData();
  InitDefaultsDataMessageStanza();
  InitDefaultsStreamAck();
  InitDefaultsSelectiveAck();
}
}  // namespace protobuf_mcs_2eproto
namespace mcs_proto {
class AppData;
class AppDataDefaultTypeInternal;
extern AppDataDefaultTypeInternal _AppData_default_instance_;
class ClientEvent;
class ClientEventDefaultTypeInternal;
extern ClientEventDefaultTypeInternal _ClientEvent_default_instance_;
class Close;
class CloseDefaultTypeInternal;
extern CloseDefaultTypeInternal _Close_default_instance_;
class DataMessageStanza;
class DataMessageStanzaDefaultTypeInternal;
extern DataMessageStanzaDefaultTypeInternal _DataMessageStanza_default_instance_;
class ErrorInfo;
class ErrorInfoDefaultTypeInternal;
extern ErrorInfoDefaultTypeInternal _ErrorInfo_default_instance_;
class Extension;
class ExtensionDefaultTypeInternal;
extern ExtensionDefaultTypeInternal _Extension_default_instance_;
class HeartbeatAck;
class HeartbeatAckDefaultTypeInternal;
extern HeartbeatAckDefaultTypeInternal _HeartbeatAck_default_instance_;
class HeartbeatConfig;
class HeartbeatConfigDefaultTypeInternal;
extern HeartbeatConfigDefaultTypeInternal _HeartbeatConfig_default_instance_;
class HeartbeatPing;
class HeartbeatPingDefaultTypeInternal;
extern HeartbeatPingDefaultTypeInternal _HeartbeatPing_default_instance_;
class HeartbeatStat;
class HeartbeatStatDefaultTypeInternal;
extern HeartbeatStatDefaultTypeInternal _HeartbeatStat_default_instance_;
class IqStanza;
class IqStanzaDefaultTypeInternal;
extern IqStanzaDefaultTypeInternal _IqStanza_default_instance_;
class LoginRequest;
class LoginRequestDefaultTypeInternal;
extern LoginRequestDefaultTypeInternal _LoginRequest_default_instance_;
class LoginResponse;
class LoginResponseDefaultTypeInternal;
extern LoginResponseDefaultTypeInternal _LoginResponse_default_instance_;
class SelectiveAck;
class SelectiveAckDefaultTypeInternal;
extern SelectiveAckDefaultTypeInternal _SelectiveAck_default_instance_;
class Setting;
class SettingDefaultTypeInternal;
extern SettingDefaultTypeInternal _Setting_default_instance_;
class StreamAck;
class StreamAckDefaultTypeInternal;
extern StreamAckDefaultTypeInternal _StreamAck_default_instance_;
class StreamErrorStanza;
class StreamErrorStanzaDefaultTypeInternal;
extern StreamErrorStanzaDefaultTypeInternal _StreamErrorStanza_default_instance_;
}  // namespace mcs_proto
namespace mcs_proto {

enum ClientEvent_Type {
  ClientEvent_Type_UNKNOWN = 0,
  ClientEvent_Type_DISCARDED_EVENTS = 1,
  ClientEvent_Type_FAILED_CONNECTION = 2,
  ClientEvent_Type_SUCCESSFUL_CONNECTION = 3
};
bool ClientEvent_Type_IsValid(int value);
const ClientEvent_Type ClientEvent_Type_Type_MIN = ClientEvent_Type_UNKNOWN;
const ClientEvent_Type ClientEvent_Type_Type_MAX = ClientEvent_Type_SUCCESSFUL_CONNECTION;
const int ClientEvent_Type_Type_ARRAYSIZE = ClientEvent_Type_Type_MAX + 1;

enum LoginRequest_AuthService {
  LoginRequest_AuthService_ANDROID_ID = 2
};
bool LoginRequest_AuthService_IsValid(int value);
const LoginRequest_AuthService LoginRequest_AuthService_AuthService_MIN = LoginRequest_AuthService_ANDROID_ID;
const LoginRequest_AuthService LoginRequest_AuthService_AuthService_MAX = LoginRequest_AuthService_ANDROID_ID;
const int LoginRequest_AuthService_AuthService_ARRAYSIZE = LoginRequest_AuthService_AuthService_MAX + 1;

enum IqStanza_IqType {
  IqStanza_IqType_GET = 0,
  IqStanza_IqType_SET = 1,
  IqStanza_IqType_RESULT = 2,
  IqStanza_IqType_IQ_ERROR = 3
};
bool IqStanza_IqType_IsValid(int value);
const IqStanza_IqType IqStanza_IqType_IqType_MIN = IqStanza_IqType_GET;
const IqStanza_IqType IqStanza_IqType_IqType_MAX = IqStanza_IqType_IQ_ERROR;
const int IqStanza_IqType_IqType_ARRAYSIZE = IqStanza_IqType_IqType_MAX + 1;

// ===================================================================

class HeartbeatPing : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:mcs_proto.HeartbeatPing) */ {
 public:
  HeartbeatPing();
  virtual ~HeartbeatPing();

  HeartbeatPing(const HeartbeatPing& from);

  inline HeartbeatPing& operator=(const HeartbeatPing& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HeartbeatPing(HeartbeatPing&& from) noexcept
    : HeartbeatPing() {
    *this = ::std::move(from);
  }

  inline HeartbeatPing& operator=(HeartbeatPing&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const HeartbeatPing& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HeartbeatPing* internal_default_instance() {
    return reinterpret_cast<const HeartbeatPing*>(
               &_HeartbeatPing_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(HeartbeatPing* other);
  friend void swap(HeartbeatPing& a, HeartbeatPing& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HeartbeatPing* New() const PROTOBUF_FINAL { return New(NULL); }

  HeartbeatPing* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const HeartbeatPing& from);
  void MergeFrom(const HeartbeatPing& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HeartbeatPing* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 stream_id = 1;
  bool has_stream_id() const;
  void clear_stream_id();
  static const int kStreamIdFieldNumber = 1;
  ::google::protobuf::int32 stream_id() const;
  void set_stream_id(::google::protobuf::int32 value);

  // optional int32 last_stream_id_received = 2;
  bool has_last_stream_id_received() const;
  void clear_last_stream_id_received();
  static const int kLastStreamIdReceivedFieldNumber = 2;
  ::google::protobuf::int32 last_stream_id_received() const;
  void set_last_stream_id_received(::google::protobuf::int32 value);

  // optional int64 status = 3;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 3;
  ::google::protobuf::int64 status() const;
  void set_status(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:mcs_proto.HeartbeatPing)
 private:
  void set_has_stream_id();
  void clear_has_stream_id();
  void set_has_last_stream_id_received();
  void clear_has_last_stream_id_received();
  void set_has_status();
  void clear_has_status();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 stream_id_;
  ::google::protobuf::int32 last_stream_id_received_;
  ::google::protobuf::int64 status_;
  friend struct ::protobuf_mcs_2eproto::TableStruct;
  friend void ::protobuf_mcs_2eproto::InitDefaultsHeartbeatPingImpl();
};
// -------------------------------------------------------------------

class HeartbeatAck : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:mcs_proto.HeartbeatAck) */ {
 public:
  HeartbeatAck();
  virtual ~HeartbeatAck();

  HeartbeatAck(const HeartbeatAck& from);

  inline HeartbeatAck& operator=(const HeartbeatAck& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HeartbeatAck(HeartbeatAck&& from) noexcept
    : HeartbeatAck() {
    *this = ::std::move(from);
  }

  inline HeartbeatAck& operator=(HeartbeatAck&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const HeartbeatAck& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HeartbeatAck* internal_default_instance() {
    return reinterpret_cast<const HeartbeatAck*>(
               &_HeartbeatAck_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(HeartbeatAck* other);
  friend void swap(HeartbeatAck& a, HeartbeatAck& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HeartbeatAck* New() const PROTOBUF_FINAL { return New(NULL); }

  HeartbeatAck* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const HeartbeatAck& from);
  void MergeFrom(const HeartbeatAck& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HeartbeatAck* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 stream_id = 1;
  bool has_stream_id() const;
  void clear_stream_id();
  static const int kStreamIdFieldNumber = 1;
  ::google::protobuf::int32 stream_id() const;
  void set_stream_id(::google::protobuf::int32 value);

  // optional int32 last_stream_id_received = 2;
  bool has_last_stream_id_received() const;
  void clear_last_stream_id_received();
  static const int kLastStreamIdReceivedFieldNumber = 2;
  ::google::protobuf::int32 last_stream_id_received() const;
  void set_last_stream_id_received(::google::protobuf::int32 value);

  // optional int64 status = 3;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 3;
  ::google::protobuf::int64 status() const;
  void set_status(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:mcs_proto.HeartbeatAck)
 private:
  void set_has_stream_id();
  void clear_has_stream_id();
  void set_has_last_stream_id_received();
  void clear_has_last_stream_id_received();
  void set_has_status();
  void clear_has_status();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 stream_id_;
  ::google::protobuf::int32 last_stream_id_received_;
  ::google::protobuf::int64 status_;
  friend struct ::protobuf_mcs_2eproto::TableStruct;
  friend void ::protobuf_mcs_2eproto::InitDefaultsHeartbeatAckImpl();
};
// -------------------------------------------------------------------

class ErrorInfo : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:mcs_proto.ErrorInfo) */ {
 public:
  ErrorInfo();
  virtual ~ErrorInfo();

  ErrorInfo(const ErrorInfo& from);

  inline ErrorInfo& operator=(const ErrorInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ErrorInfo(ErrorInfo&& from) noexcept
    : ErrorInfo() {
    *this = ::std::move(from);
  }

  inline ErrorInfo& operator=(ErrorInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ErrorInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ErrorInfo* internal_default_instance() {
    return reinterpret_cast<const ErrorInfo*>(
               &_ErrorInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(ErrorInfo* other);
  friend void swap(ErrorInfo& a, ErrorInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ErrorInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  ErrorInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ErrorInfo& from);
  void MergeFrom(const ErrorInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ErrorInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string message = 2;
  bool has_message() const;
  void clear_message();
  static const int kMessageFieldNumber = 2;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // optional string type = 3;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // optional .mcs_proto.Extension extension = 4;
  bool has_extension() const;
  void clear_extension();
  static const int kExtensionFieldNumber = 4;
  const ::mcs_proto::Extension& extension() const;
  ::mcs_proto::Extension* release_extension();
  ::mcs_proto::Extension* mutable_extension();
  void set_allocated_extension(::mcs_proto::Extension* extension);

  // required int32 code = 1;
  bool has_code() const;
  void clear_code();
  static const int kCodeFieldNumber = 1;
  ::google::protobuf::int32 code() const;
  void set_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mcs_proto.ErrorInfo)
 private:
  void set_has_code();
  void clear_has_code();
  void set_has_message();
  void clear_has_message();
  void set_has_type();
  void clear_has_type();
  void set_has_extension();
  void clear_has_extension();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::mcs_proto::Extension* extension_;
  ::google::protobuf::int32 code_;
  friend struct ::protobuf_mcs_2eproto::TableStruct;
  friend void ::protobuf_mcs_2eproto::InitDefaultsErrorInfoImpl();
};
// -------------------------------------------------------------------

class Setting : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:mcs_proto.Setting) */ {
 public:
  Setting();
  virtual ~Setting();

  Setting(const Setting& from);

  inline Setting& operator=(const Setting& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Setting(Setting&& from) noexcept
    : Setting() {
    *this = ::std::move(from);
  }

  inline Setting& operator=(Setting&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Setting& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Setting* internal_default_instance() {
    return reinterpret_cast<const Setting*>(
               &_Setting_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(Setting* other);
  friend void swap(Setting& a, Setting& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Setting* New() const PROTOBUF_FINAL { return New(NULL); }

  Setting* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Setting& from);
  void MergeFrom(const Setting& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Setting* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required string value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:mcs_proto.Setting)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_value();
  void clear_has_value();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  friend struct ::protobuf_mcs_2eproto::TableStruct;
  friend void ::protobuf_mcs_2eproto::InitDefaultsSettingImpl();
};
// -------------------------------------------------------------------

class HeartbeatStat : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:mcs_proto.HeartbeatStat) */ {
 public:
  HeartbeatStat();
  virtual ~HeartbeatStat();

  HeartbeatStat(const HeartbeatStat& from);

  inline HeartbeatStat& operator=(const HeartbeatStat& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HeartbeatStat(HeartbeatStat&& from) noexcept
    : HeartbeatStat() {
    *this = ::std::move(from);
  }

  inline HeartbeatStat& operator=(HeartbeatStat&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const HeartbeatStat& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HeartbeatStat* internal_default_instance() {
    return reinterpret_cast<const HeartbeatStat*>(
               &_HeartbeatStat_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(HeartbeatStat* other);
  friend void swap(HeartbeatStat& a, HeartbeatStat& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HeartbeatStat* New() const PROTOBUF_FINAL { return New(NULL); }

  HeartbeatStat* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const HeartbeatStat& from);
  void MergeFrom(const HeartbeatStat& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HeartbeatStat* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ip = 1;
  bool has_ip() const;
  void clear_ip();
  static const int kIpFieldNumber = 1;
  const ::std::string& ip() const;
  void set_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_ip(::std::string&& value);
  #endif
  void set_ip(const char* value);
  void set_ip(const char* value, size_t size);
  ::std::string* mutable_ip();
  ::std::string* release_ip();
  void set_allocated_ip(::std::string* ip);

  // required bool timeout = 2;
  bool has_timeout() const;
  void clear_timeout();
  static const int kTimeoutFieldNumber = 2;
  bool timeout() const;
  void set_timeout(bool value);

  // required int32 interval_ms = 3;
  bool has_interval_ms() const;
  void clear_interval_ms();
  static const int kIntervalMsFieldNumber = 3;
  ::google::protobuf::int32 interval_ms() const;
  void set_interval_ms(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mcs_proto.HeartbeatStat)
 private:
  void set_has_ip();
  void clear_has_ip();
  void set_has_timeout();
  void clear_has_timeout();
  void set_has_interval_ms();
  void clear_has_interval_ms();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr ip_;
  bool timeout_;
  ::google::protobuf::int32 interval_ms_;
  friend struct ::protobuf_mcs_2eproto::TableStruct;
  friend void ::protobuf_mcs_2eproto::InitDefaultsHeartbeatStatImpl();
};
// -------------------------------------------------------------------

class HeartbeatConfig : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:mcs_proto.HeartbeatConfig) */ {
 public:
  HeartbeatConfig();
  virtual ~HeartbeatConfig();

  HeartbeatConfig(const HeartbeatConfig& from);

  inline HeartbeatConfig& operator=(const HeartbeatConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HeartbeatConfig(HeartbeatConfig&& from) noexcept
    : HeartbeatConfig() {
    *this = ::std::move(from);
  }

  inline HeartbeatConfig& operator=(HeartbeatConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const HeartbeatConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HeartbeatConfig* internal_default_instance() {
    return reinterpret_cast<const HeartbeatConfig*>(
               &_HeartbeatConfig_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(HeartbeatConfig* other);
  friend void swap(HeartbeatConfig& a, HeartbeatConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HeartbeatConfig* New() const PROTOBUF_FINAL { return New(NULL); }

  HeartbeatConfig* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const HeartbeatConfig& from);
  void MergeFrom(const HeartbeatConfig& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HeartbeatConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ip = 2;
  bool has_ip() const;
  void clear_ip();
  static const int kIpFieldNumber = 2;
  const ::std::string& ip() const;
  void set_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_ip(::std::string&& value);
  #endif
  void set_ip(const char* value);
  void set_ip(const char* value, size_t size);
  ::std::string* mutable_ip();
  ::std::string* release_ip();
  void set_allocated_ip(::std::string* ip);

  // optional bool upload_stat = 1;
  bool has_upload_stat() const;
  void clear_upload_stat();
  static const int kUploadStatFieldNumber = 1;
  bool upload_stat() const;
  void set_upload_stat(bool value);

  // optional int32 interval_ms = 3;
  bool has_interval_ms() const;
  void clear_interval_ms();
  static const int kIntervalMsFieldNumber = 3;
  ::google::protobuf::int32 interval_ms() const;
  void set_interval_ms(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mcs_proto.HeartbeatConfig)
 private:
  void set_has_upload_stat();
  void clear_has_upload_stat();
  void set_has_ip();
  void clear_has_ip();
  void set_has_interval_ms();
  void clear_has_interval_ms();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr ip_;
  bool upload_stat_;
  ::google::protobuf::int32 interval_ms_;
  friend struct ::protobuf_mcs_2eproto::TableStruct;
  friend void ::protobuf_mcs_2eproto::InitDefaultsHeartbeatConfigImpl();
};
// -------------------------------------------------------------------

class ClientEvent : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:mcs_proto.ClientEvent) */ {
 public:
  ClientEvent();
  virtual ~ClientEvent();

  ClientEvent(const ClientEvent& from);

  inline ClientEvent& operator=(const ClientEvent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClientEvent(ClientEvent&& from) noexcept
    : ClientEvent() {
    *this = ::std::move(from);
  }

  inline ClientEvent& operator=(ClientEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ClientEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientEvent* internal_default_instance() {
    return reinterpret_cast<const ClientEvent*>(
               &_ClientEvent_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(ClientEvent* other);
  friend void swap(ClientEvent& a, ClientEvent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClientEvent* New() const PROTOBUF_FINAL { return New(NULL); }

  ClientEvent* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const ClientEvent& from);
  void MergeFrom(const ClientEvent& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClientEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef ClientEvent_Type Type;
  static const Type UNKNOWN =
    ClientEvent_Type_UNKNOWN;
  static const Type DISCARDED_EVENTS =
    ClientEvent_Type_DISCARDED_EVENTS;
  static const Type FAILED_CONNECTION =
    ClientEvent_Type_FAILED_CONNECTION;
  static const Type SUCCESSFUL_CONNECTION =
    ClientEvent_Type_SUCCESSFUL_CONNECTION;
  static inline bool Type_IsValid(int value) {
    return ClientEvent_Type_IsValid(value);
  }
  static const Type Type_MIN =
    ClientEvent_Type_Type_MIN;
  static const Type Type_MAX =
    ClientEvent_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    ClientEvent_Type_Type_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .mcs_proto.ClientEvent.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::mcs_proto::ClientEvent_Type type() const;
  void set_type(::mcs_proto::ClientEvent_Type value);

  // optional uint32 number_discarded_events = 100;
  bool has_number_discarded_events() const;
  void clear_number_discarded_events();
  static const int kNumberDiscardedEventsFieldNumber = 100;
  ::google::protobuf::uint32 number_discarded_events() const;
  void set_number_discarded_events(::google::protobuf::uint32 value);

  // optional uint64 time_connection_started_ms = 202;
  bool has_time_connection_started_ms() const;
  void clear_time_connection_started_ms();
  static const int kTimeConnectionStartedMsFieldNumber = 202;
  ::google::protobuf::uint64 time_connection_started_ms() const;
  void set_time_connection_started_ms(::google::protobuf::uint64 value);

  // optional int32 network_type = 200;
  bool has_network_type() const;
  void clear_network_type();
  static const int kNetworkTypeFieldNumber = 200;
  ::google::protobuf::int32 network_type() const;
  void set_network_type(::google::protobuf::int32 value);

  // optional int32 error_code = 204;
  bool has_error_code() const;
  void clear_error_code();
  static const int kErrorCodeFieldNumber = 204;
  ::google::protobuf::int32 error_code() const;
  void set_error_code(::google::protobuf::int32 value);

  // optional uint64 time_connection_ended_ms = 203;
  bool has_time_connection_ended_ms() const;
  void clear_time_connection_ended_ms();
  static const int kTimeConnectionEndedMsFieldNumber = 203;
  ::google::protobuf::uint64 time_connection_ended_ms() const;
  void set_time_connection_ended_ms(::google::protobuf::uint64 value);

  // optional uint64 time_connection_established_ms = 300;
  bool has_time_connection_established_ms() const;
  void clear_time_connection_established_ms();
  static const int kTimeConnectionEstablishedMsFieldNumber = 300;
  ::google::protobuf::uint64 time_connection_established_ms() const;
  void set_time_connection_established_ms(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mcs_proto.ClientEvent)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_number_discarded_events();
  void clear_has_number_discarded_events();
  void set_has_network_type();
  void clear_has_network_type();
  void set_has_time_connection_started_ms();
  void clear_has_time_connection_started_ms();
  void set_has_time_connection_ended_ms();
  void clear_has_time_connection_ended_ms();
  void set_has_error_code();
  void clear_has_error_code();
  void set_has_time_connection_established_ms();
  void clear_has_time_connection_established_ms();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  int type_;
  ::google::protobuf::uint32 number_discarded_events_;
  ::google::protobuf::uint64 time_connection_started_ms_;
  ::google::protobuf::int32 network_type_;
  ::google::protobuf::int32 error_code_;
  ::google::protobuf::uint64 time_connection_ended_ms_;
  ::google::protobuf::uint64 time_connection_established_ms_;
  friend struct ::protobuf_mcs_2eproto::TableStruct;
  friend void ::protobuf_mcs_2eproto::InitDefaultsClientEventImpl();
};
// -------------------------------------------------------------------

class LoginRequest : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:mcs_proto.LoginRequest) */ {
 public:
  LoginRequest();
  virtual ~LoginRequest();

  LoginRequest(const LoginRequest& from);

  inline LoginRequest& operator=(const LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LoginRequest(LoginRequest&& from) noexcept
    : LoginRequest() {
    *this = ::std::move(from);
  }

  inline LoginRequest& operator=(LoginRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const LoginRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoginRequest* internal_default_instance() {
    return reinterpret_cast<const LoginRequest*>(
               &_LoginRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(LoginRequest* other);
  friend void swap(LoginRequest& a, LoginRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LoginRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  LoginRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const LoginRequest& from);
  void MergeFrom(const LoginRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LoginRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef LoginRequest_AuthService AuthService;
  static const AuthService ANDROID_ID =
    LoginRequest_AuthService_ANDROID_ID;
  static inline bool AuthService_IsValid(int value) {
    return LoginRequest_AuthService_IsValid(value);
  }
  static const AuthService AuthService_MIN =
    LoginRequest_AuthService_AuthService_MIN;
  static const AuthService AuthService_MAX =
    LoginRequest_AuthService_AuthService_MAX;
  static const int AuthService_ARRAYSIZE =
    LoginRequest_AuthService_AuthService_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // repeated .mcs_proto.Setting setting = 8;
  int setting_size() const;
  void clear_setting();
  static const int kSettingFieldNumber = 8;
  const ::mcs_proto::Setting& setting(int index) const;
  ::mcs_proto::Setting* mutable_setting(int index);
  ::mcs_proto::Setting* add_setting();
  ::google::protobuf::RepeatedPtrField< ::mcs_proto::Setting >*
      mutable_setting();
  const ::google::protobuf::RepeatedPtrField< ::mcs_proto::Setting >&
      setting() const;

  // repeated string received_persistent_id = 10;
  int received_persistent_id_size() const;
  void clear_received_persistent_id();
  static const int kReceivedPersistentIdFieldNumber = 10;
  const ::std::string& received_persistent_id(int index) const;
  ::std::string* mutable_received_persistent_id(int index);
  void set_received_persistent_id(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_received_persistent_id(int index, ::std::string&& value);
  #endif
  void set_received_persistent_id(int index, const char* value);
  void set_received_persistent_id(int index, const char* value, size_t size);
  ::std::string* add_received_persistent_id();
  void add_received_persistent_id(const ::std::string& value);
  #if LANG_CXX11
  void add_received_persistent_id(::std::string&& value);
  #endif
  void add_received_persistent_id(const char* value);
  void add_received_persistent_id(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& received_persistent_id() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_received_persistent_id();

  // repeated .mcs_proto.ClientEvent client_event = 22;
  int client_event_size() const;
  void clear_client_event();
  static const int kClientEventFieldNumber = 22;
  const ::mcs_proto::ClientEvent& client_event(int index) const;
  ::mcs_proto::ClientEvent* mutable_client_event(int index);
  ::mcs_proto::ClientEvent* add_client_event();
  ::google::protobuf::RepeatedPtrField< ::mcs_proto::ClientEvent >*
      mutable_client_event();
  const ::google::protobuf::RepeatedPtrField< ::mcs_proto::ClientEvent >&
      client_event() const;

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // required string domain = 2;
  bool has_domain() const;
  void clear_domain();
  static const int kDomainFieldNumber = 2;
  const ::std::string& domain() const;
  void set_domain(const ::std::string& value);
  #if LANG_CXX11
  void set_domain(::std::string&& value);
  #endif
  void set_domain(const char* value);
  void set_domain(const char* value, size_t size);
  ::std::string* mutable_domain();
  ::std::string* release_domain();
  void set_allocated_domain(::std::string* domain);

  // required string user = 3;
  bool has_user() const;
  void clear_user();
  static const int kUserFieldNumber = 3;
  const ::std::string& user() const;
  void set_user(const ::std::string& value);
  #if LANG_CXX11
  void set_user(::std::string&& value);
  #endif
  void set_user(const char* value);
  void set_user(const char* value, size_t size);
  ::std::string* mutable_user();
  ::std::string* release_user();
  void set_allocated_user(::std::string* user);

  // required string resource = 4;
  bool has_resource() const;
  void clear_resource();
  static const int kResourceFieldNumber = 4;
  const ::std::string& resource() const;
  void set_resource(const ::std::string& value);
  #if LANG_CXX11
  void set_resource(::std::string&& value);
  #endif
  void set_resource(const char* value);
  void set_resource(const char* value, size_t size);
  ::std::string* mutable_resource();
  ::std::string* release_resource();
  void set_allocated_resource(::std::string* resource);

  // required string auth_token = 5;
  bool has_auth_token() const;
  void clear_auth_token();
  static const int kAuthTokenFieldNumber = 5;
  const ::std::string& auth_token() const;
  void set_auth_token(const ::std::string& value);
  #if LANG_CXX11
  void set_auth_token(::std::string&& value);
  #endif
  void set_auth_token(const char* value);
  void set_auth_token(const char* value, size_t size);
  ::std::string* mutable_auth_token();
  ::std::string* release_auth_token();
  void set_allocated_auth_token(::std::string* auth_token);

  // optional string device_id = 6;
  bool has_device_id() const;
  void clear_device_id();
  static const int kDeviceIdFieldNumber = 6;
  const ::std::string& device_id() const;
  void set_device_id(const ::std::string& value);
  #if LANG_CXX11
  void set_device_id(::std::string&& value);
  #endif
  void set_device_id(const char* value);
  void set_device_id(const char* value, size_t size);
  ::std::string* mutable_device_id();
  ::std::string* release_device_id();
  void set_allocated_device_id(::std::string* device_id);

  // optional .mcs_proto.HeartbeatStat heartbeat_stat = 13;
  bool has_heartbeat_stat() const;
  void clear_heartbeat_stat();
  static const int kHeartbeatStatFieldNumber = 13;
  const ::mcs_proto::HeartbeatStat& heartbeat_stat() const;
  ::mcs_proto::HeartbeatStat* release_heartbeat_stat();
  ::mcs_proto::HeartbeatStat* mutable_heartbeat_stat();
  void set_allocated_heartbeat_stat(::mcs_proto::HeartbeatStat* heartbeat_stat);

  // optional int64 last_rmq_id = 7;
  bool has_last_rmq_id() const;
  void clear_last_rmq_id();
  static const int kLastRmqIdFieldNumber = 7;
  ::google::protobuf::int64 last_rmq_id() const;
  void set_last_rmq_id(::google::protobuf::int64 value);

  // optional bool adaptive_heartbeat = 12;
  bool has_adaptive_heartbeat() const;
  void clear_adaptive_heartbeat();
  static const int kAdaptiveHeartbeatFieldNumber = 12;
  bool adaptive_heartbeat() const;
  void set_adaptive_heartbeat(bool value);

  // optional bool use_rmq2 = 14;
  bool has_use_rmq2() const;
  void clear_use_rmq2();
  static const int kUseRmq2FieldNumber = 14;
  bool use_rmq2() const;
  void set_use_rmq2(bool value);

  // optional int32 network_type = 17;
  bool has_network_type() const;
  void clear_network_type();
  static const int kNetworkTypeFieldNumber = 17;
  ::google::protobuf::int32 network_type() const;
  void set_network_type(::google::protobuf::int32 value);

  // optional int64 account_id = 15;
  bool has_account_id() const;
  void clear_account_id();
  static const int kAccountIdFieldNumber = 15;
  ::google::protobuf::int64 account_id() const;
  void set_account_id(::google::protobuf::int64 value);

  // optional int64 status = 18;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 18;
  ::google::protobuf::int64 status() const;
  void set_status(::google::protobuf::int64 value);

  // optional .mcs_proto.LoginRequest.AuthService auth_service = 16;
  bool has_auth_service() const;
  void clear_auth_service();
  static const int kAuthServiceFieldNumber = 16;
  ::mcs_proto::LoginRequest_AuthService auth_service() const;
  void set_auth_service(::mcs_proto::LoginRequest_AuthService value);

  // @@protoc_insertion_point(class_scope:mcs_proto.LoginRequest)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_domain();
  void clear_has_domain();
  void set_has_user();
  void clear_has_user();
  void set_has_resource();
  void clear_has_resource();
  void set_has_auth_token();
  void clear_has_auth_token();
  void set_has_device_id();
  void clear_has_device_id();
  void set_has_last_rmq_id();
  void clear_has_last_rmq_id();
  void set_has_adaptive_heartbeat();
  void clear_has_adaptive_heartbeat();
  void set_has_heartbeat_stat();
  void clear_has_heartbeat_stat();
  void set_has_use_rmq2();
  void clear_has_use_rmq2();
  void set_has_account_id();
  void clear_has_account_id();
  void set_has_auth_service();
  void clear_has_auth_service();
  void set_has_network_type();
  void clear_has_network_type();
  void set_has_status();
  void clear_has_status();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mcs_proto::Setting > setting_;
  ::google::protobuf::RepeatedPtrField< ::std::string> received_persistent_id_;
  ::google::protobuf::RepeatedPtrField< ::mcs_proto::ClientEvent > client_event_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr domain_;
  ::google::protobuf::internal::ArenaStringPtr user_;
  ::google::protobuf::internal::ArenaStringPtr resource_;
  ::google::protobuf::internal::ArenaStringPtr auth_token_;
  ::google::protobuf::internal::ArenaStringPtr device_id_;
  ::mcs_proto::HeartbeatStat* heartbeat_stat_;
  ::google::protobuf::int64 last_rmq_id_;
  bool adaptive_heartbeat_;
  bool use_rmq2_;
  ::google::protobuf::int32 network_type_;
  ::google::protobuf::int64 account_id_;
  ::google::protobuf::int64 status_;
  int auth_service_;
  friend struct ::protobuf_mcs_2eproto::TableStruct;
  friend void ::protobuf_mcs_2eproto::InitDefaultsLoginRequestImpl();
};
// -------------------------------------------------------------------

class LoginResponse : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:mcs_proto.LoginResponse) */ {
 public:
  LoginResponse();
  virtual ~LoginResponse();

  LoginResponse(const LoginResponse& from);

  inline LoginResponse& operator=(const LoginResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LoginResponse(LoginResponse&& from) noexcept
    : LoginResponse() {
    *this = ::std::move(from);
  }

  inline LoginResponse& operator=(LoginResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const LoginResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoginResponse* internal_default_instance() {
    return reinterpret_cast<const LoginResponse*>(
               &_LoginResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(LoginResponse* other);
  friend void swap(LoginResponse& a, LoginResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LoginResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  LoginResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const LoginResponse& from);
  void MergeFrom(const LoginResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LoginResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mcs_proto.Setting setting = 4;
  int setting_size() const;
  void clear_setting();
  static const int kSettingFieldNumber = 4;
  const ::mcs_proto::Setting& setting(int index) const;
  ::mcs_proto::Setting* mutable_setting(int index);
  ::mcs_proto::Setting* add_setting();
  ::google::protobuf::RepeatedPtrField< ::mcs_proto::Setting >*
      mutable_setting();
  const ::google::protobuf::RepeatedPtrField< ::mcs_proto::Setting >&
      setting() const;

  // required string id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // optional string jid = 2;
  bool has_jid() const;
  void clear_jid();
  static const int kJidFieldNumber = 2;
  const ::std::string& jid() const;
  void set_jid(const ::std::string& value);
  #if LANG_CXX11
  void set_jid(::std::string&& value);
  #endif
  void set_jid(const char* value);
  void set_jid(const char* value, size_t size);
  ::std::string* mutable_jid();
  ::std::string* release_jid();
  void set_allocated_jid(::std::string* jid);

  // optional .mcs_proto.ErrorInfo error = 3;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 3;
  const ::mcs_proto::ErrorInfo& error() const;
  ::mcs_proto::ErrorInfo* release_error();
  ::mcs_proto::ErrorInfo* mutable_error();
  void set_allocated_error(::mcs_proto::ErrorInfo* error);

  // optional .mcs_proto.HeartbeatConfig heartbeat_config = 7;
  bool has_heartbeat_config() const;
  void clear_heartbeat_config();
  static const int kHeartbeatConfigFieldNumber = 7;
  const ::mcs_proto::HeartbeatConfig& heartbeat_config() const;
  ::mcs_proto::HeartbeatConfig* release_heartbeat_config();
  ::mcs_proto::HeartbeatConfig* mutable_heartbeat_config();
  void set_allocated_heartbeat_config(::mcs_proto::HeartbeatConfig* heartbeat_config);

  // optional int32 stream_id = 5;
  bool has_stream_id() const;
  void clear_stream_id();
  static const int kStreamIdFieldNumber = 5;
  ::google::protobuf::int32 stream_id() const;
  void set_stream_id(::google::protobuf::int32 value);

  // optional int32 last_stream_id_received = 6;
  bool has_last_stream_id_received() const;
  void clear_last_stream_id_received();
  static const int kLastStreamIdReceivedFieldNumber = 6;
  ::google::protobuf::int32 last_stream_id_received() const;
  void set_last_stream_id_received(::google::protobuf::int32 value);

  // optional int64 server_timestamp = 8;
  bool has_server_timestamp() const;
  void clear_server_timestamp();
  static const int kServerTimestampFieldNumber = 8;
  ::google::protobuf::int64 server_timestamp() const;
  void set_server_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:mcs_proto.LoginResponse)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_jid();
  void clear_has_jid();
  void set_has_error();
  void clear_has_error();
  void set_has_stream_id();
  void clear_has_stream_id();
  void set_has_last_stream_id_received();
  void clear_has_last_stream_id_received();
  void set_has_heartbeat_config();
  void clear_has_heartbeat_config();
  void set_has_server_timestamp();
  void clear_has_server_timestamp();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mcs_proto::Setting > setting_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr jid_;
  ::mcs_proto::ErrorInfo* error_;
  ::mcs_proto::HeartbeatConfig* heartbeat_config_;
  ::google::protobuf::int32 stream_id_;
  ::google::protobuf::int32 last_stream_id_received_;
  ::google::protobuf::int64 server_timestamp_;
  friend struct ::protobuf_mcs_2eproto::TableStruct;
  friend void ::protobuf_mcs_2eproto::InitDefaultsLoginResponseImpl();
};
// -------------------------------------------------------------------

class StreamErrorStanza : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:mcs_proto.StreamErrorStanza) */ {
 public:
  StreamErrorStanza();
  virtual ~StreamErrorStanza();

  StreamErrorStanza(const StreamErrorStanza& from);

  inline StreamErrorStanza& operator=(const StreamErrorStanza& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StreamErrorStanza(StreamErrorStanza&& from) noexcept
    : StreamErrorStanza() {
    *this = ::std::move(from);
  }

  inline StreamErrorStanza& operator=(StreamErrorStanza&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const StreamErrorStanza& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StreamErrorStanza* internal_default_instance() {
    return reinterpret_cast<const StreamErrorStanza*>(
               &_StreamErrorStanza_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(StreamErrorStanza* other);
  friend void swap(StreamErrorStanza& a, StreamErrorStanza& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StreamErrorStanza* New() const PROTOBUF_FINAL { return New(NULL); }

  StreamErrorStanza* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const StreamErrorStanza& from);
  void MergeFrom(const StreamErrorStanza& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StreamErrorStanza* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // optional string text = 2;
  bool has_text() const;
  void clear_text();
  static const int kTextFieldNumber = 2;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  #if LANG_CXX11
  void set_text(::std::string&& value);
  #endif
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // @@protoc_insertion_point(class_scope:mcs_proto.StreamErrorStanza)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_text();
  void clear_has_text();

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  friend struct ::protobuf_mcs_2eproto::TableStruct;
  friend void ::protobuf_mcs_2eproto::InitDefaultsStreamErrorStanzaImpl();
};
// -------------------------------------------------------------------

class Close : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:mcs_proto.Close) */ {
 public:
  Close();
  virtual ~Close();

  Close(const Close& from);

  inline Close& operator=(const Close& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Close(Close&& from) noexcept
    : Close() {
    *this = ::std::move(from);
  }

  inline Close& operator=(Close&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Close& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Close* internal_default_instance() {
    return reinterpret_cast<const Close*>(
               &_Close_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(Close* other);
  friend void swap(Close& a, Close& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Close* New() const PROTOBUF_FINAL { return New(NULL); }

  Close* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Close& from);
  void MergeFrom(const Close& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Close* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mcs_proto.Close)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct ::protobuf_mcs_2eproto::TableStruct;
  friend void ::protobuf_mcs_2eproto::InitDefaultsCloseImpl();
};
// -------------------------------------------------------------------

class Extension : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:mcs_proto.Extension) */ {
 public:
  Extension();
  virtual ~Extension();

  Extension(const Extension& from);

  inline Extension& operator=(const Extension& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Extension(Extension&& from) noexcept
    : Extension() {
    *this = ::std::move(from);
  }

  inline Extension& operator=(Extension&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const Extension& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Extension* internal_default_instance() {
    return reinterpret_cast<const Extension*>(
               &_Extension_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(Extension* other);
  friend void swap(Extension& a, Extension& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Extension* New() const PROTOBUF_FINAL { return New(NULL); }

  Extension* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const Extension& from);
  void MergeFrom(const Extension& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Extension* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes data = 2;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 2;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // required int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mcs_proto.Extension)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_data();
  void clear_has_data();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::int32 id_;
  friend struct ::protobuf_mcs_2eproto::TableStruct;
  friend void ::protobuf_mcs_2eproto::InitDefaultsExtensionImpl();
};
// -------------------------------------------------------------------

class IqStanza : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:mcs_proto.IqStanza) */ {
 public:
  IqStanza();
  virtual ~IqStanza();

  IqStanza(const IqStanza& from);

  inline IqStanza& operator=(const IqStanza& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IqStanza(IqStanza&& from) noexcept
    : IqStanza() {
    *this = ::std::move(from);
  }

  inline IqStanza& operator=(IqStanza&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const IqStanza& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IqStanza* internal_default_instance() {
    return reinterpret_cast<const IqStanza*>(
               &_IqStanza_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(IqStanza* other);
  friend void swap(IqStanza& a, IqStanza& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IqStanza* New() const PROTOBUF_FINAL { return New(NULL); }

  IqStanza* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const IqStanza& from);
  void MergeFrom(const IqStanza& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(IqStanza* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef IqStanza_IqType IqType;
  static const IqType GET =
    IqStanza_IqType_GET;
  static const IqType SET =
    IqStanza_IqType_SET;
  static const IqType RESULT =
    IqStanza_IqType_RESULT;
  static const IqType IQ_ERROR =
    IqStanza_IqType_IQ_ERROR;
  static inline bool IqType_IsValid(int value) {
    return IqStanza_IqType_IsValid(value);
  }
  static const IqType IqType_MIN =
    IqStanza_IqType_IqType_MIN;
  static const IqType IqType_MAX =
    IqStanza_IqType_IqType_MAX;
  static const int IqType_ARRAYSIZE =
    IqStanza_IqType_IqType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required string id = 3;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 3;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // optional string from = 4;
  bool has_from() const;
  void clear_from();
  static const int kFromFieldNumber = 4;
  const ::std::string& from() const;
  void set_from(const ::std::string& value);
  #if LANG_CXX11
  void set_from(::std::string&& value);
  #endif
  void set_from(const char* value);
  void set_from(const char* value, size_t size);
  ::std::string* mutable_from();
  ::std::string* release_from();
  void set_allocated_from(::std::string* from);

  // optional string to = 5;
  bool has_to() const;
  void clear_to();
  static const int kToFieldNumber = 5;
  const ::std::string& to() const;
  void set_to(const ::std::string& value);
  #if LANG_CXX11
  void set_to(::std::string&& value);
  #endif
  void set_to(const char* value);
  void set_to(const char* value, size_t size);
  ::std::string* mutable_to();
  ::std::string* release_to();
  void set_allocated_to(::std::string* to);

  // optional string persistent_id = 8;
  bool has_persistent_id() const;
  void clear_persistent_id();
  static const int kPersistentIdFieldNumber = 8;
  const ::std::string& persistent_id() const;
  void set_persistent_id(const ::std::string& value);
  #if LANG_CXX11
  void set_persistent_id(::std::string&& value);
  #endif
  void set_persistent_id(const char* value);
  void set_persistent_id(const char* value, size_t size);
  ::std::string* mutable_persistent_id();
  ::std::string* release_persistent_id();
  void set_allocated_persistent_id(::std::string* persistent_id);

  // optional .mcs_proto.ErrorInfo error = 6;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 6;
  const ::mcs_proto::ErrorInfo& error() const;
  ::mcs_proto::ErrorInfo* release_error();
  ::mcs_proto::ErrorInfo* mutable_error();
  void set_allocated_error(::mcs_proto::ErrorInfo* error);

  // optional .mcs_proto.Extension extension = 7;
  bool has_extension() const;
  void clear_extension();
  static const int kExtensionFieldNumber = 7;
  const ::mcs_proto::Extension& extension() const;
  ::mcs_proto::Extension* release_extension();
  ::mcs_proto::Extension* mutable_extension();
  void set_allocated_extension(::mcs_proto::Extension* extension);

  // optional int64 rmq_id = 1;
  bool has_rmq_id() const;
  void clear_rmq_id();
  static const int kRmqIdFieldNumber = 1;
  ::google::protobuf::int64 rmq_id() const;
  void set_rmq_id(::google::protobuf::int64 value);

  // required .mcs_proto.IqStanza.IqType type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::mcs_proto::IqStanza_IqType type() const;
  void set_type(::mcs_proto::IqStanza_IqType value);

  // optional int32 stream_id = 9;
  bool has_stream_id() const;
  void clear_stream_id();
  static const int kStreamIdFieldNumber = 9;
  ::google::protobuf::int32 stream_id() const;
  void set_stream_id(::google::protobuf::int32 value);

  // optional int64 account_id = 11;
  bool has_account_id() const;
  void clear_account_id();
  static const int kAccountIdFieldNumber = 11;
  ::google::protobuf::int64 account_id() const;
  void set_account_id(::google::protobuf::int64 value);

  // optional int64 status = 12;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 12;
  ::google::protobuf::int64 status() const;
  void set_status(::google::protobuf::int64 value);

  // optional int32 last_stream_id_received = 10;
  bool has_last_stream_id_received() const;
  void clear_last_stream_id_received();
  static const int kLastStreamIdReceivedFieldNumber = 10;
  ::google::protobuf::int32 last_stream_id_received() const;
  void set_last_stream_id_received(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mcs_proto.IqStanza)
 private:
  void set_has_rmq_id();
  void clear_has_rmq_id();
  void set_has_type();
  void clear_has_type();
  void set_has_id();
  void clear_has_id();
  void set_has_from();
  void clear_has_from();
  void set_has_to();
  void clear_has_to();
  void set_has_error();
  void clear_has_error();
  void set_has_extension();
  void clear_has_extension();
  void set_has_persistent_id();
  void clear_has_persistent_id();
  void set_has_stream_id();
  void clear_has_stream_id();
  void set_has_last_stream_id_received();
  void clear_has_last_stream_id_received();
  void set_has_account_id();
  void clear_has_account_id();
  void set_has_status();
  void clear_has_status();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr from_;
  ::google::protobuf::internal::ArenaStringPtr to_;
  ::google::protobuf::internal::ArenaStringPtr persistent_id_;
  ::mcs_proto::ErrorInfo* error_;
  ::mcs_proto::Extension* extension_;
  ::google::protobuf::int64 rmq_id_;
  int type_;
  ::google::protobuf::int32 stream_id_;
  ::google::protobuf::int64 account_id_;
  ::google::protobuf::int64 status_;
  ::google::protobuf::int32 last_stream_id_received_;
  friend struct ::protobuf_mcs_2eproto::TableStruct;
  friend void ::protobuf_mcs_2eproto::InitDefaultsIqStanzaImpl();
};
// -------------------------------------------------------------------

class AppData : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:mcs_proto.AppData) */ {
 public:
  AppData();
  virtual ~AppData();

  AppData(const AppData& from);

  inline AppData& operator=(const AppData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AppData(AppData&& from) noexcept
    : AppData() {
    *this = ::std::move(from);
  }

  inline AppData& operator=(AppData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const AppData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AppData* internal_default_instance() {
    return reinterpret_cast<const AppData*>(
               &_AppData_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(AppData* other);
  friend void swap(AppData& a, AppData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AppData* New() const PROTOBUF_FINAL { return New(NULL); }

  AppData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const AppData& from);
  void MergeFrom(const AppData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AppData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // required string value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:mcs_proto.AppData)
 private:
  void set_has_key();
  void clear_has_key();
  void set_has_value();
  void clear_has_value();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  friend struct ::protobuf_mcs_2eproto::TableStruct;
  friend void ::protobuf_mcs_2eproto::InitDefaultsAppDataImpl();
};
// -------------------------------------------------------------------

class DataMessageStanza : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:mcs_proto.DataMessageStanza) */ {
 public:
  DataMessageStanza();
  virtual ~DataMessageStanza();

  DataMessageStanza(const DataMessageStanza& from);

  inline DataMessageStanza& operator=(const DataMessageStanza& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DataMessageStanza(DataMessageStanza&& from) noexcept
    : DataMessageStanza() {
    *this = ::std::move(from);
  }

  inline DataMessageStanza& operator=(DataMessageStanza&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const DataMessageStanza& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DataMessageStanza* internal_default_instance() {
    return reinterpret_cast<const DataMessageStanza*>(
               &_DataMessageStanza_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(DataMessageStanza* other);
  friend void swap(DataMessageStanza& a, DataMessageStanza& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DataMessageStanza* New() const PROTOBUF_FINAL { return New(NULL); }

  DataMessageStanza* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const DataMessageStanza& from);
  void MergeFrom(const DataMessageStanza& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DataMessageStanza* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mcs_proto.AppData app_data = 7;
  int app_data_size() const;
  void clear_app_data();
  static const int kAppDataFieldNumber = 7;
  const ::mcs_proto::AppData& app_data(int index) const;
  ::mcs_proto::AppData* mutable_app_data(int index);
  ::mcs_proto::AppData* add_app_data();
  ::google::protobuf::RepeatedPtrField< ::mcs_proto::AppData >*
      mutable_app_data();
  const ::google::protobuf::RepeatedPtrField< ::mcs_proto::AppData >&
      app_data() const;

  // optional string id = 2;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 2;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // required string from = 3;
  bool has_from() const;
  void clear_from();
  static const int kFromFieldNumber = 3;
  const ::std::string& from() const;
  void set_from(const ::std::string& value);
  #if LANG_CXX11
  void set_from(::std::string&& value);
  #endif
  void set_from(const char* value);
  void set_from(const char* value, size_t size);
  ::std::string* mutable_from();
  ::std::string* release_from();
  void set_allocated_from(::std::string* from);

  // optional string to = 4;
  bool has_to() const;
  void clear_to();
  static const int kToFieldNumber = 4;
  const ::std::string& to() const;
  void set_to(const ::std::string& value);
  #if LANG_CXX11
  void set_to(::std::string&& value);
  #endif
  void set_to(const char* value);
  void set_to(const char* value, size_t size);
  ::std::string* mutable_to();
  ::std::string* release_to();
  void set_allocated_to(::std::string* to);

  // required string category = 5;
  bool has_category() const;
  void clear_category();
  static const int kCategoryFieldNumber = 5;
  const ::std::string& category() const;
  void set_category(const ::std::string& value);
  #if LANG_CXX11
  void set_category(::std::string&& value);
  #endif
  void set_category(const char* value);
  void set_category(const char* value, size_t size);
  ::std::string* mutable_category();
  ::std::string* release_category();
  void set_allocated_category(::std::string* category);

  // optional string token = 6;
  bool has_token() const;
  void clear_token();
  static const int kTokenFieldNumber = 6;
  const ::std::string& token() const;
  void set_token(const ::std::string& value);
  #if LANG_CXX11
  void set_token(::std::string&& value);
  #endif
  void set_token(const char* value);
  void set_token(const char* value, size_t size);
  ::std::string* mutable_token();
  ::std::string* release_token();
  void set_allocated_token(::std::string* token);

  // optional string persistent_id = 9;
  bool has_persistent_id() const;
  void clear_persistent_id();
  static const int kPersistentIdFieldNumber = 9;
  const ::std::string& persistent_id() const;
  void set_persistent_id(const ::std::string& value);
  #if LANG_CXX11
  void set_persistent_id(::std::string&& value);
  #endif
  void set_persistent_id(const char* value);
  void set_persistent_id(const char* value, size_t size);
  ::std::string* mutable_persistent_id();
  ::std::string* release_persistent_id();
  void set_allocated_persistent_id(::std::string* persistent_id);

  // optional string reg_id = 13;
  bool has_reg_id() const;
  void clear_reg_id();
  static const int kRegIdFieldNumber = 13;
  const ::std::string& reg_id() const;
  void set_reg_id(const ::std::string& value);
  #if LANG_CXX11
  void set_reg_id(::std::string&& value);
  #endif
  void set_reg_id(const char* value);
  void set_reg_id(const char* value, size_t size);
  ::std::string* mutable_reg_id();
  ::std::string* release_reg_id();
  void set_allocated_reg_id(::std::string* reg_id);

  // optional bytes raw_data = 21;
  bool has_raw_data() const;
  void clear_raw_data();
  static const int kRawDataFieldNumber = 21;
  const ::std::string& raw_data() const;
  void set_raw_data(const ::std::string& value);
  #if LANG_CXX11
  void set_raw_data(::std::string&& value);
  #endif
  void set_raw_data(const char* value);
  void set_raw_data(const void* value, size_t size);
  ::std::string* mutable_raw_data();
  ::std::string* release_raw_data();
  void set_allocated_raw_data(::std::string* raw_data);

  // optional int32 stream_id = 10;
  bool has_stream_id() const;
  void clear_stream_id();
  static const int kStreamIdFieldNumber = 10;
  ::google::protobuf::int32 stream_id() const;
  void set_stream_id(::google::protobuf::int32 value);

  // optional int32 last_stream_id_received = 11;
  bool has_last_stream_id_received() const;
  void clear_last_stream_id_received();
  static const int kLastStreamIdReceivedFieldNumber = 11;
  ::google::protobuf::int32 last_stream_id_received() const;
  void set_last_stream_id_received(::google::protobuf::int32 value);

  // optional int64 device_user_id = 16;
  bool has_device_user_id() const;
  void clear_device_user_id();
  static const int kDeviceUserIdFieldNumber = 16;
  ::google::protobuf::int64 device_user_id() const;
  void set_device_user_id(::google::protobuf::int64 value);

  // optional bool from_trusted_server = 8;
  bool has_from_trusted_server() const;
  void clear_from_trusted_server();
  static const int kFromTrustedServerFieldNumber = 8;
  bool from_trusted_server() const;
  void set_from_trusted_server(bool value);

  // optional bool immediate_ack = 24;
  bool has_immediate_ack() const;
  void clear_immediate_ack();
  static const int kImmediateAckFieldNumber = 24;
  bool immediate_ack() const;
  void set_immediate_ack(bool value);

  // optional int32 ttl = 17;
  bool has_ttl() const;
  void clear_ttl();
  static const int kTtlFieldNumber = 17;
  ::google::protobuf::int32 ttl() const;
  void set_ttl(::google::protobuf::int32 value);

  // optional int64 sent = 18;
  bool has_sent() const;
  void clear_sent();
  static const int kSentFieldNumber = 18;
  ::google::protobuf::int64 sent() const;
  void set_sent(::google::protobuf::int64 value);

  // optional int32 queued = 19;
  bool has_queued() const;
  void clear_queued();
  static const int kQueuedFieldNumber = 19;
  ::google::protobuf::int32 queued() const;
  void set_queued(::google::protobuf::int32 value);

  // optional int64 status = 20;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 20;
  ::google::protobuf::int64 status() const;
  void set_status(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:mcs_proto.DataMessageStanza)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_from();
  void clear_has_from();
  void set_has_to();
  void clear_has_to();
  void set_has_category();
  void clear_has_category();
  void set_has_token();
  void clear_has_token();
  void set_has_from_trusted_server();
  void clear_has_from_trusted_server();
  void set_has_persistent_id();
  void clear_has_persistent_id();
  void set_has_stream_id();
  void clear_has_stream_id();
  void set_has_last_stream_id_received();
  void clear_has_last_stream_id_received();
  void set_has_reg_id();
  void clear_has_reg_id();
  void set_has_device_user_id();
  void clear_has_device_user_id();
  void set_has_ttl();
  void clear_has_ttl();
  void set_has_sent();
  void clear_has_sent();
  void set_has_queued();
  void clear_has_queued();
  void set_has_status();
  void clear_has_status();
  void set_has_raw_data();
  void clear_has_raw_data();
  void set_has_immediate_ack();
  void clear_has_immediate_ack();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mcs_proto::AppData > app_data_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr from_;
  ::google::protobuf::internal::ArenaStringPtr to_;
  ::google::protobuf::internal::ArenaStringPtr category_;
  ::google::protobuf::internal::ArenaStringPtr token_;
  ::google::protobuf::internal::ArenaStringPtr persistent_id_;
  ::google::protobuf::internal::ArenaStringPtr reg_id_;
  ::google::protobuf::internal::ArenaStringPtr raw_data_;
  ::google::protobuf::int32 stream_id_;
  ::google::protobuf::int32 last_stream_id_received_;
  ::google::protobuf::int64 device_user_id_;
  bool from_trusted_server_;
  bool immediate_ack_;
  ::google::protobuf::int32 ttl_;
  ::google::protobuf::int64 sent_;
  ::google::protobuf::int32 queued_;
  ::google::protobuf::int64 status_;
  friend struct ::protobuf_mcs_2eproto::TableStruct;
  friend void ::protobuf_mcs_2eproto::InitDefaultsDataMessageStanzaImpl();
};
// -------------------------------------------------------------------

class StreamAck : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:mcs_proto.StreamAck) */ {
 public:
  StreamAck();
  virtual ~StreamAck();

  StreamAck(const StreamAck& from);

  inline StreamAck& operator=(const StreamAck& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StreamAck(StreamAck&& from) noexcept
    : StreamAck() {
    *this = ::std::move(from);
  }

  inline StreamAck& operator=(StreamAck&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const StreamAck& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StreamAck* internal_default_instance() {
    return reinterpret_cast<const StreamAck*>(
               &_StreamAck_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(StreamAck* other);
  friend void swap(StreamAck& a, StreamAck& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StreamAck* New() const PROTOBUF_FINAL { return New(NULL); }

  StreamAck* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const StreamAck& from);
  void MergeFrom(const StreamAck& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StreamAck* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mcs_proto.StreamAck)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct ::protobuf_mcs_2eproto::TableStruct;
  friend void ::protobuf_mcs_2eproto::InitDefaultsStreamAckImpl();
};
// -------------------------------------------------------------------

class SelectiveAck : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:mcs_proto.SelectiveAck) */ {
 public:
  SelectiveAck();
  virtual ~SelectiveAck();

  SelectiveAck(const SelectiveAck& from);

  inline SelectiveAck& operator=(const SelectiveAck& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SelectiveAck(SelectiveAck&& from) noexcept
    : SelectiveAck() {
    *this = ::std::move(from);
  }

  inline SelectiveAck& operator=(SelectiveAck&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const SelectiveAck& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SelectiveAck* internal_default_instance() {
    return reinterpret_cast<const SelectiveAck*>(
               &_SelectiveAck_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(SelectiveAck* other);
  friend void swap(SelectiveAck& a, SelectiveAck& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SelectiveAck* New() const PROTOBUF_FINAL { return New(NULL); }

  SelectiveAck* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from)
    PROTOBUF_FINAL;
  void CopyFrom(const SelectiveAck& from);
  void MergeFrom(const SelectiveAck& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  void DiscardUnknownFields();
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SelectiveAck* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::std::string GetTypeName() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string id = 1;
  int id_size() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id(int index) const;
  ::std::string* mutable_id(int index);
  void set_id(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_id(int index, ::std::string&& value);
  #endif
  void set_id(int index, const char* value);
  void set_id(int index, const char* value, size_t size);
  ::std::string* add_id();
  void add_id(const ::std::string& value);
  #if LANG_CXX11
  void add_id(::std::string&& value);
  #endif
  void add_id(const char* value);
  void add_id(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& id() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_id();

  // @@protoc_insertion_point(class_scope:mcs_proto.SelectiveAck)
 private:

  ::google::protobuf::internal::InternalMetadataWithArenaLite _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> id_;
  friend struct ::protobuf_mcs_2eproto::TableStruct;
  friend void ::protobuf_mcs_2eproto::InitDefaultsSelectiveAckImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// HeartbeatPing

// optional int32 stream_id = 1;
inline bool HeartbeatPing::has_stream_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HeartbeatPing::set_has_stream_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HeartbeatPing::clear_has_stream_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HeartbeatPing::clear_stream_id() {
  stream_id_ = 0;
  clear_has_stream_id();
}
inline ::google::protobuf::int32 HeartbeatPing::stream_id() const {
  // @@protoc_insertion_point(field_get:mcs_proto.HeartbeatPing.stream_id)
  return stream_id_;
}
inline void HeartbeatPing::set_stream_id(::google::protobuf::int32 value) {
  set_has_stream_id();
  stream_id_ = value;
  // @@protoc_insertion_point(field_set:mcs_proto.HeartbeatPing.stream_id)
}

// optional int32 last_stream_id_received = 2;
inline bool HeartbeatPing::has_last_stream_id_received() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HeartbeatPing::set_has_last_stream_id_received() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HeartbeatPing::clear_has_last_stream_id_received() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HeartbeatPing::clear_last_stream_id_received() {
  last_stream_id_received_ = 0;
  clear_has_last_stream_id_received();
}
inline ::google::protobuf::int32 HeartbeatPing::last_stream_id_received() const {
  // @@protoc_insertion_point(field_get:mcs_proto.HeartbeatPing.last_stream_id_received)
  return last_stream_id_received_;
}
inline void HeartbeatPing::set_last_stream_id_received(::google::protobuf::int32 value) {
  set_has_last_stream_id_received();
  last_stream_id_received_ = value;
  // @@protoc_insertion_point(field_set:mcs_proto.HeartbeatPing.last_stream_id_received)
}

// optional int64 status = 3;
inline bool HeartbeatPing::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HeartbeatPing::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HeartbeatPing::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HeartbeatPing::clear_status() {
  status_ = GOOGLE_LONGLONG(0);
  clear_has_status();
}
inline ::google::protobuf::int64 HeartbeatPing::status() const {
  // @@protoc_insertion_point(field_get:mcs_proto.HeartbeatPing.status)
  return status_;
}
inline void HeartbeatPing::set_status(::google::protobuf::int64 value) {
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:mcs_proto.HeartbeatPing.status)
}

// -------------------------------------------------------------------

// HeartbeatAck

// optional int32 stream_id = 1;
inline bool HeartbeatAck::has_stream_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HeartbeatAck::set_has_stream_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HeartbeatAck::clear_has_stream_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HeartbeatAck::clear_stream_id() {
  stream_id_ = 0;
  clear_has_stream_id();
}
inline ::google::protobuf::int32 HeartbeatAck::stream_id() const {
  // @@protoc_insertion_point(field_get:mcs_proto.HeartbeatAck.stream_id)
  return stream_id_;
}
inline void HeartbeatAck::set_stream_id(::google::protobuf::int32 value) {
  set_has_stream_id();
  stream_id_ = value;
  // @@protoc_insertion_point(field_set:mcs_proto.HeartbeatAck.stream_id)
}

// optional int32 last_stream_id_received = 2;
inline bool HeartbeatAck::has_last_stream_id_received() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HeartbeatAck::set_has_last_stream_id_received() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HeartbeatAck::clear_has_last_stream_id_received() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HeartbeatAck::clear_last_stream_id_received() {
  last_stream_id_received_ = 0;
  clear_has_last_stream_id_received();
}
inline ::google::protobuf::int32 HeartbeatAck::last_stream_id_received() const {
  // @@protoc_insertion_point(field_get:mcs_proto.HeartbeatAck.last_stream_id_received)
  return last_stream_id_received_;
}
inline void HeartbeatAck::set_last_stream_id_received(::google::protobuf::int32 value) {
  set_has_last_stream_id_received();
  last_stream_id_received_ = value;
  // @@protoc_insertion_point(field_set:mcs_proto.HeartbeatAck.last_stream_id_received)
}

// optional int64 status = 3;
inline bool HeartbeatAck::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HeartbeatAck::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HeartbeatAck::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HeartbeatAck::clear_status() {
  status_ = GOOGLE_LONGLONG(0);
  clear_has_status();
}
inline ::google::protobuf::int64 HeartbeatAck::status() const {
  // @@protoc_insertion_point(field_get:mcs_proto.HeartbeatAck.status)
  return status_;
}
inline void HeartbeatAck::set_status(::google::protobuf::int64 value) {
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:mcs_proto.HeartbeatAck.status)
}

// -------------------------------------------------------------------

// ErrorInfo

// required int32 code = 1;
inline bool ErrorInfo::has_code() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ErrorInfo::set_has_code() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ErrorInfo::clear_has_code() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ErrorInfo::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 ErrorInfo::code() const {
  // @@protoc_insertion_point(field_get:mcs_proto.ErrorInfo.code)
  return code_;
}
inline void ErrorInfo::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
  // @@protoc_insertion_point(field_set:mcs_proto.ErrorInfo.code)
}

// optional string message = 2;
inline bool ErrorInfo::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ErrorInfo::set_has_message() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ErrorInfo::clear_has_message() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ErrorInfo::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message();
}
inline const ::std::string& ErrorInfo::message() const {
  // @@protoc_insertion_point(field_get:mcs_proto.ErrorInfo.message)
  return message_.GetNoArena();
}
inline void ErrorInfo::set_message(const ::std::string& value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcs_proto.ErrorInfo.message)
}
#if LANG_CXX11
inline void ErrorInfo::set_message(::std::string&& value) {
  set_has_message();
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcs_proto.ErrorInfo.message)
}
#endif
inline void ErrorInfo::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcs_proto.ErrorInfo.message)
}
inline void ErrorInfo::set_message(const char* value, size_t size) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcs_proto.ErrorInfo.message)
}
inline ::std::string* ErrorInfo::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:mcs_proto.ErrorInfo.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ErrorInfo::release_message() {
  // @@protoc_insertion_point(field_release:mcs_proto.ErrorInfo.message)
  clear_has_message();
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ErrorInfo::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:mcs_proto.ErrorInfo.message)
}

// optional string type = 3;
inline bool ErrorInfo::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ErrorInfo::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ErrorInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ErrorInfo::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_type();
}
inline const ::std::string& ErrorInfo::type() const {
  // @@protoc_insertion_point(field_get:mcs_proto.ErrorInfo.type)
  return type_.GetNoArena();
}
inline void ErrorInfo::set_type(const ::std::string& value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcs_proto.ErrorInfo.type)
}
#if LANG_CXX11
inline void ErrorInfo::set_type(::std::string&& value) {
  set_has_type();
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcs_proto.ErrorInfo.type)
}
#endif
inline void ErrorInfo::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcs_proto.ErrorInfo.type)
}
inline void ErrorInfo::set_type(const char* value, size_t size) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcs_proto.ErrorInfo.type)
}
inline ::std::string* ErrorInfo::mutable_type() {
  set_has_type();
  // @@protoc_insertion_point(field_mutable:mcs_proto.ErrorInfo.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ErrorInfo::release_type() {
  // @@protoc_insertion_point(field_release:mcs_proto.ErrorInfo.type)
  clear_has_type();
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ErrorInfo::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    set_has_type();
  } else {
    clear_has_type();
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:mcs_proto.ErrorInfo.type)
}

// optional .mcs_proto.Extension extension = 4;
inline bool ErrorInfo::has_extension() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ErrorInfo::set_has_extension() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ErrorInfo::clear_has_extension() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ErrorInfo::clear_extension() {
  if (extension_ != NULL) extension_->Clear();
  clear_has_extension();
}
inline const ::mcs_proto::Extension& ErrorInfo::extension() const {
  const ::mcs_proto::Extension* p = extension_;
  // @@protoc_insertion_point(field_get:mcs_proto.ErrorInfo.extension)
  return p != NULL ? *p : *reinterpret_cast<const ::mcs_proto::Extension*>(
      &::mcs_proto::_Extension_default_instance_);
}
inline ::mcs_proto::Extension* ErrorInfo::release_extension() {
  // @@protoc_insertion_point(field_release:mcs_proto.ErrorInfo.extension)
  clear_has_extension();
  ::mcs_proto::Extension* temp = extension_;
  extension_ = NULL;
  return temp;
}
inline ::mcs_proto::Extension* ErrorInfo::mutable_extension() {
  set_has_extension();
  if (extension_ == NULL) {
    extension_ = new ::mcs_proto::Extension;
  }
  // @@protoc_insertion_point(field_mutable:mcs_proto.ErrorInfo.extension)
  return extension_;
}
inline void ErrorInfo::set_allocated_extension(::mcs_proto::Extension* extension) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete extension_;
  }
  if (extension) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      extension = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, extension, submessage_arena);
    }
    set_has_extension();
  } else {
    clear_has_extension();
  }
  extension_ = extension;
  // @@protoc_insertion_point(field_set_allocated:mcs_proto.ErrorInfo.extension)
}

// -------------------------------------------------------------------

// Setting

// required string name = 1;
inline bool Setting::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Setting::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Setting::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Setting::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Setting::name() const {
  // @@protoc_insertion_point(field_get:mcs_proto.Setting.name)
  return name_.GetNoArena();
}
inline void Setting::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcs_proto.Setting.name)
}
#if LANG_CXX11
inline void Setting::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcs_proto.Setting.name)
}
#endif
inline void Setting::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcs_proto.Setting.name)
}
inline void Setting::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcs_proto.Setting.name)
}
inline ::std::string* Setting::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:mcs_proto.Setting.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Setting::release_name() {
  // @@protoc_insertion_point(field_release:mcs_proto.Setting.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Setting::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mcs_proto.Setting.name)
}

// required string value = 2;
inline bool Setting::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Setting::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Setting::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Setting::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
inline const ::std::string& Setting::value() const {
  // @@protoc_insertion_point(field_get:mcs_proto.Setting.value)
  return value_.GetNoArena();
}
inline void Setting::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcs_proto.Setting.value)
}
#if LANG_CXX11
inline void Setting::set_value(::std::string&& value) {
  set_has_value();
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcs_proto.Setting.value)
}
#endif
inline void Setting::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcs_proto.Setting.value)
}
inline void Setting::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcs_proto.Setting.value)
}
inline ::std::string* Setting::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:mcs_proto.Setting.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Setting::release_value() {
  // @@protoc_insertion_point(field_release:mcs_proto.Setting.value)
  clear_has_value();
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Setting::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:mcs_proto.Setting.value)
}

// -------------------------------------------------------------------

// HeartbeatStat

// required string ip = 1;
inline bool HeartbeatStat::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HeartbeatStat::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HeartbeatStat::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HeartbeatStat::clear_ip() {
  ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ip();
}
inline const ::std::string& HeartbeatStat::ip() const {
  // @@protoc_insertion_point(field_get:mcs_proto.HeartbeatStat.ip)
  return ip_.GetNoArena();
}
inline void HeartbeatStat::set_ip(const ::std::string& value) {
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcs_proto.HeartbeatStat.ip)
}
#if LANG_CXX11
inline void HeartbeatStat::set_ip(::std::string&& value) {
  set_has_ip();
  ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcs_proto.HeartbeatStat.ip)
}
#endif
inline void HeartbeatStat::set_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcs_proto.HeartbeatStat.ip)
}
inline void HeartbeatStat::set_ip(const char* value, size_t size) {
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcs_proto.HeartbeatStat.ip)
}
inline ::std::string* HeartbeatStat::mutable_ip() {
  set_has_ip();
  // @@protoc_insertion_point(field_mutable:mcs_proto.HeartbeatStat.ip)
  return ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HeartbeatStat::release_ip() {
  // @@protoc_insertion_point(field_release:mcs_proto.HeartbeatStat.ip)
  clear_has_ip();
  return ip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HeartbeatStat::set_allocated_ip(::std::string* ip) {
  if (ip != NULL) {
    set_has_ip();
  } else {
    clear_has_ip();
  }
  ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip);
  // @@protoc_insertion_point(field_set_allocated:mcs_proto.HeartbeatStat.ip)
}

// required bool timeout = 2;
inline bool HeartbeatStat::has_timeout() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HeartbeatStat::set_has_timeout() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HeartbeatStat::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HeartbeatStat::clear_timeout() {
  timeout_ = false;
  clear_has_timeout();
}
inline bool HeartbeatStat::timeout() const {
  // @@protoc_insertion_point(field_get:mcs_proto.HeartbeatStat.timeout)
  return timeout_;
}
inline void HeartbeatStat::set_timeout(bool value) {
  set_has_timeout();
  timeout_ = value;
  // @@protoc_insertion_point(field_set:mcs_proto.HeartbeatStat.timeout)
}

// required int32 interval_ms = 3;
inline bool HeartbeatStat::has_interval_ms() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HeartbeatStat::set_has_interval_ms() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HeartbeatStat::clear_has_interval_ms() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HeartbeatStat::clear_interval_ms() {
  interval_ms_ = 0;
  clear_has_interval_ms();
}
inline ::google::protobuf::int32 HeartbeatStat::interval_ms() const {
  // @@protoc_insertion_point(field_get:mcs_proto.HeartbeatStat.interval_ms)
  return interval_ms_;
}
inline void HeartbeatStat::set_interval_ms(::google::protobuf::int32 value) {
  set_has_interval_ms();
  interval_ms_ = value;
  // @@protoc_insertion_point(field_set:mcs_proto.HeartbeatStat.interval_ms)
}

// -------------------------------------------------------------------

// HeartbeatConfig

// optional bool upload_stat = 1;
inline bool HeartbeatConfig::has_upload_stat() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HeartbeatConfig::set_has_upload_stat() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HeartbeatConfig::clear_has_upload_stat() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HeartbeatConfig::clear_upload_stat() {
  upload_stat_ = false;
  clear_has_upload_stat();
}
inline bool HeartbeatConfig::upload_stat() const {
  // @@protoc_insertion_point(field_get:mcs_proto.HeartbeatConfig.upload_stat)
  return upload_stat_;
}
inline void HeartbeatConfig::set_upload_stat(bool value) {
  set_has_upload_stat();
  upload_stat_ = value;
  // @@protoc_insertion_point(field_set:mcs_proto.HeartbeatConfig.upload_stat)
}

// optional string ip = 2;
inline bool HeartbeatConfig::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HeartbeatConfig::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HeartbeatConfig::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HeartbeatConfig::clear_ip() {
  ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ip();
}
inline const ::std::string& HeartbeatConfig::ip() const {
  // @@protoc_insertion_point(field_get:mcs_proto.HeartbeatConfig.ip)
  return ip_.GetNoArena();
}
inline void HeartbeatConfig::set_ip(const ::std::string& value) {
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcs_proto.HeartbeatConfig.ip)
}
#if LANG_CXX11
inline void HeartbeatConfig::set_ip(::std::string&& value) {
  set_has_ip();
  ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcs_proto.HeartbeatConfig.ip)
}
#endif
inline void HeartbeatConfig::set_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcs_proto.HeartbeatConfig.ip)
}
inline void HeartbeatConfig::set_ip(const char* value, size_t size) {
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcs_proto.HeartbeatConfig.ip)
}
inline ::std::string* HeartbeatConfig::mutable_ip() {
  set_has_ip();
  // @@protoc_insertion_point(field_mutable:mcs_proto.HeartbeatConfig.ip)
  return ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HeartbeatConfig::release_ip() {
  // @@protoc_insertion_point(field_release:mcs_proto.HeartbeatConfig.ip)
  clear_has_ip();
  return ip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HeartbeatConfig::set_allocated_ip(::std::string* ip) {
  if (ip != NULL) {
    set_has_ip();
  } else {
    clear_has_ip();
  }
  ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip);
  // @@protoc_insertion_point(field_set_allocated:mcs_proto.HeartbeatConfig.ip)
}

// optional int32 interval_ms = 3;
inline bool HeartbeatConfig::has_interval_ms() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HeartbeatConfig::set_has_interval_ms() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HeartbeatConfig::clear_has_interval_ms() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HeartbeatConfig::clear_interval_ms() {
  interval_ms_ = 0;
  clear_has_interval_ms();
}
inline ::google::protobuf::int32 HeartbeatConfig::interval_ms() const {
  // @@protoc_insertion_point(field_get:mcs_proto.HeartbeatConfig.interval_ms)
  return interval_ms_;
}
inline void HeartbeatConfig::set_interval_ms(::google::protobuf::int32 value) {
  set_has_interval_ms();
  interval_ms_ = value;
  // @@protoc_insertion_point(field_set:mcs_proto.HeartbeatConfig.interval_ms)
}

// -------------------------------------------------------------------

// ClientEvent

// optional .mcs_proto.ClientEvent.Type type = 1;
inline bool ClientEvent::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientEvent::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientEvent::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientEvent::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mcs_proto::ClientEvent_Type ClientEvent::type() const {
  // @@protoc_insertion_point(field_get:mcs_proto.ClientEvent.type)
  return static_cast< ::mcs_proto::ClientEvent_Type >(type_);
}
inline void ClientEvent::set_type(::mcs_proto::ClientEvent_Type value) {
  assert(::mcs_proto::ClientEvent_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mcs_proto.ClientEvent.type)
}

// optional uint32 number_discarded_events = 100;
inline bool ClientEvent::has_number_discarded_events() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientEvent::set_has_number_discarded_events() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientEvent::clear_has_number_discarded_events() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientEvent::clear_number_discarded_events() {
  number_discarded_events_ = 0u;
  clear_has_number_discarded_events();
}
inline ::google::protobuf::uint32 ClientEvent::number_discarded_events() const {
  // @@protoc_insertion_point(field_get:mcs_proto.ClientEvent.number_discarded_events)
  return number_discarded_events_;
}
inline void ClientEvent::set_number_discarded_events(::google::protobuf::uint32 value) {
  set_has_number_discarded_events();
  number_discarded_events_ = value;
  // @@protoc_insertion_point(field_set:mcs_proto.ClientEvent.number_discarded_events)
}

// optional int32 network_type = 200;
inline bool ClientEvent::has_network_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClientEvent::set_has_network_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClientEvent::clear_has_network_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClientEvent::clear_network_type() {
  network_type_ = 0;
  clear_has_network_type();
}
inline ::google::protobuf::int32 ClientEvent::network_type() const {
  // @@protoc_insertion_point(field_get:mcs_proto.ClientEvent.network_type)
  return network_type_;
}
inline void ClientEvent::set_network_type(::google::protobuf::int32 value) {
  set_has_network_type();
  network_type_ = value;
  // @@protoc_insertion_point(field_set:mcs_proto.ClientEvent.network_type)
}

// optional uint64 time_connection_started_ms = 202;
inline bool ClientEvent::has_time_connection_started_ms() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientEvent::set_has_time_connection_started_ms() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientEvent::clear_has_time_connection_started_ms() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientEvent::clear_time_connection_started_ms() {
  time_connection_started_ms_ = GOOGLE_ULONGLONG(0);
  clear_has_time_connection_started_ms();
}
inline ::google::protobuf::uint64 ClientEvent::time_connection_started_ms() const {
  // @@protoc_insertion_point(field_get:mcs_proto.ClientEvent.time_connection_started_ms)
  return time_connection_started_ms_;
}
inline void ClientEvent::set_time_connection_started_ms(::google::protobuf::uint64 value) {
  set_has_time_connection_started_ms();
  time_connection_started_ms_ = value;
  // @@protoc_insertion_point(field_set:mcs_proto.ClientEvent.time_connection_started_ms)
}

// optional uint64 time_connection_ended_ms = 203;
inline bool ClientEvent::has_time_connection_ended_ms() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ClientEvent::set_has_time_connection_ended_ms() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ClientEvent::clear_has_time_connection_ended_ms() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ClientEvent::clear_time_connection_ended_ms() {
  time_connection_ended_ms_ = GOOGLE_ULONGLONG(0);
  clear_has_time_connection_ended_ms();
}
inline ::google::protobuf::uint64 ClientEvent::time_connection_ended_ms() const {
  // @@protoc_insertion_point(field_get:mcs_proto.ClientEvent.time_connection_ended_ms)
  return time_connection_ended_ms_;
}
inline void ClientEvent::set_time_connection_ended_ms(::google::protobuf::uint64 value) {
  set_has_time_connection_ended_ms();
  time_connection_ended_ms_ = value;
  // @@protoc_insertion_point(field_set:mcs_proto.ClientEvent.time_connection_ended_ms)
}

// optional int32 error_code = 204;
inline bool ClientEvent::has_error_code() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClientEvent::set_has_error_code() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ClientEvent::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ClientEvent::clear_error_code() {
  error_code_ = 0;
  clear_has_error_code();
}
inline ::google::protobuf::int32 ClientEvent::error_code() const {
  // @@protoc_insertion_point(field_get:mcs_proto.ClientEvent.error_code)
  return error_code_;
}
inline void ClientEvent::set_error_code(::google::protobuf::int32 value) {
  set_has_error_code();
  error_code_ = value;
  // @@protoc_insertion_point(field_set:mcs_proto.ClientEvent.error_code)
}

// optional uint64 time_connection_established_ms = 300;
inline bool ClientEvent::has_time_connection_established_ms() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ClientEvent::set_has_time_connection_established_ms() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ClientEvent::clear_has_time_connection_established_ms() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ClientEvent::clear_time_connection_established_ms() {
  time_connection_established_ms_ = GOOGLE_ULONGLONG(0);
  clear_has_time_connection_established_ms();
}
inline ::google::protobuf::uint64 ClientEvent::time_connection_established_ms() const {
  // @@protoc_insertion_point(field_get:mcs_proto.ClientEvent.time_connection_established_ms)
  return time_connection_established_ms_;
}
inline void ClientEvent::set_time_connection_established_ms(::google::protobuf::uint64 value) {
  set_has_time_connection_established_ms();
  time_connection_established_ms_ = value;
  // @@protoc_insertion_point(field_set:mcs_proto.ClientEvent.time_connection_established_ms)
}

// -------------------------------------------------------------------

// LoginRequest

// required string id = 1;
inline bool LoginRequest::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginRequest::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginRequest::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginRequest::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& LoginRequest::id() const {
  // @@protoc_insertion_point(field_get:mcs_proto.LoginRequest.id)
  return id_.GetNoArena();
}
inline void LoginRequest::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcs_proto.LoginRequest.id)
}
#if LANG_CXX11
inline void LoginRequest::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcs_proto.LoginRequest.id)
}
#endif
inline void LoginRequest::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcs_proto.LoginRequest.id)
}
inline void LoginRequest::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcs_proto.LoginRequest.id)
}
inline ::std::string* LoginRequest::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:mcs_proto.LoginRequest.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginRequest::release_id() {
  // @@protoc_insertion_point(field_release:mcs_proto.LoginRequest.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginRequest::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:mcs_proto.LoginRequest.id)
}

// required string domain = 2;
inline bool LoginRequest::has_domain() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginRequest::set_has_domain() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginRequest::clear_has_domain() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginRequest::clear_domain() {
  domain_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_domain();
}
inline const ::std::string& LoginRequest::domain() const {
  // @@protoc_insertion_point(field_get:mcs_proto.LoginRequest.domain)
  return domain_.GetNoArena();
}
inline void LoginRequest::set_domain(const ::std::string& value) {
  set_has_domain();
  domain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcs_proto.LoginRequest.domain)
}
#if LANG_CXX11
inline void LoginRequest::set_domain(::std::string&& value) {
  set_has_domain();
  domain_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcs_proto.LoginRequest.domain)
}
#endif
inline void LoginRequest::set_domain(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_domain();
  domain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcs_proto.LoginRequest.domain)
}
inline void LoginRequest::set_domain(const char* value, size_t size) {
  set_has_domain();
  domain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcs_proto.LoginRequest.domain)
}
inline ::std::string* LoginRequest::mutable_domain() {
  set_has_domain();
  // @@protoc_insertion_point(field_mutable:mcs_proto.LoginRequest.domain)
  return domain_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginRequest::release_domain() {
  // @@protoc_insertion_point(field_release:mcs_proto.LoginRequest.domain)
  clear_has_domain();
  return domain_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginRequest::set_allocated_domain(::std::string* domain) {
  if (domain != NULL) {
    set_has_domain();
  } else {
    clear_has_domain();
  }
  domain_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), domain);
  // @@protoc_insertion_point(field_set_allocated:mcs_proto.LoginRequest.domain)
}

// required string user = 3;
inline bool LoginRequest::has_user() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginRequest::set_has_user() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginRequest::clear_has_user() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginRequest::clear_user() {
  user_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_user();
}
inline const ::std::string& LoginRequest::user() const {
  // @@protoc_insertion_point(field_get:mcs_proto.LoginRequest.user)
  return user_.GetNoArena();
}
inline void LoginRequest::set_user(const ::std::string& value) {
  set_has_user();
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcs_proto.LoginRequest.user)
}
#if LANG_CXX11
inline void LoginRequest::set_user(::std::string&& value) {
  set_has_user();
  user_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcs_proto.LoginRequest.user)
}
#endif
inline void LoginRequest::set_user(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_user();
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcs_proto.LoginRequest.user)
}
inline void LoginRequest::set_user(const char* value, size_t size) {
  set_has_user();
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcs_proto.LoginRequest.user)
}
inline ::std::string* LoginRequest::mutable_user() {
  set_has_user();
  // @@protoc_insertion_point(field_mutable:mcs_proto.LoginRequest.user)
  return user_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginRequest::release_user() {
  // @@protoc_insertion_point(field_release:mcs_proto.LoginRequest.user)
  clear_has_user();
  return user_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginRequest::set_allocated_user(::std::string* user) {
  if (user != NULL) {
    set_has_user();
  } else {
    clear_has_user();
  }
  user_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user);
  // @@protoc_insertion_point(field_set_allocated:mcs_proto.LoginRequest.user)
}

// required string resource = 4;
inline bool LoginRequest::has_resource() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoginRequest::set_has_resource() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoginRequest::clear_has_resource() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoginRequest::clear_resource() {
  resource_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_resource();
}
inline const ::std::string& LoginRequest::resource() const {
  // @@protoc_insertion_point(field_get:mcs_proto.LoginRequest.resource)
  return resource_.GetNoArena();
}
inline void LoginRequest::set_resource(const ::std::string& value) {
  set_has_resource();
  resource_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcs_proto.LoginRequest.resource)
}
#if LANG_CXX11
inline void LoginRequest::set_resource(::std::string&& value) {
  set_has_resource();
  resource_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcs_proto.LoginRequest.resource)
}
#endif
inline void LoginRequest::set_resource(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_resource();
  resource_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcs_proto.LoginRequest.resource)
}
inline void LoginRequest::set_resource(const char* value, size_t size) {
  set_has_resource();
  resource_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcs_proto.LoginRequest.resource)
}
inline ::std::string* LoginRequest::mutable_resource() {
  set_has_resource();
  // @@protoc_insertion_point(field_mutable:mcs_proto.LoginRequest.resource)
  return resource_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginRequest::release_resource() {
  // @@protoc_insertion_point(field_release:mcs_proto.LoginRequest.resource)
  clear_has_resource();
  return resource_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginRequest::set_allocated_resource(::std::string* resource) {
  if (resource != NULL) {
    set_has_resource();
  } else {
    clear_has_resource();
  }
  resource_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), resource);
  // @@protoc_insertion_point(field_set_allocated:mcs_proto.LoginRequest.resource)
}

// required string auth_token = 5;
inline bool LoginRequest::has_auth_token() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LoginRequest::set_has_auth_token() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LoginRequest::clear_has_auth_token() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LoginRequest::clear_auth_token() {
  auth_token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_auth_token();
}
inline const ::std::string& LoginRequest::auth_token() const {
  // @@protoc_insertion_point(field_get:mcs_proto.LoginRequest.auth_token)
  return auth_token_.GetNoArena();
}
inline void LoginRequest::set_auth_token(const ::std::string& value) {
  set_has_auth_token();
  auth_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcs_proto.LoginRequest.auth_token)
}
#if LANG_CXX11
inline void LoginRequest::set_auth_token(::std::string&& value) {
  set_has_auth_token();
  auth_token_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcs_proto.LoginRequest.auth_token)
}
#endif
inline void LoginRequest::set_auth_token(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_auth_token();
  auth_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcs_proto.LoginRequest.auth_token)
}
inline void LoginRequest::set_auth_token(const char* value, size_t size) {
  set_has_auth_token();
  auth_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcs_proto.LoginRequest.auth_token)
}
inline ::std::string* LoginRequest::mutable_auth_token() {
  set_has_auth_token();
  // @@protoc_insertion_point(field_mutable:mcs_proto.LoginRequest.auth_token)
  return auth_token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginRequest::release_auth_token() {
  // @@protoc_insertion_point(field_release:mcs_proto.LoginRequest.auth_token)
  clear_has_auth_token();
  return auth_token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginRequest::set_allocated_auth_token(::std::string* auth_token) {
  if (auth_token != NULL) {
    set_has_auth_token();
  } else {
    clear_has_auth_token();
  }
  auth_token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), auth_token);
  // @@protoc_insertion_point(field_set_allocated:mcs_proto.LoginRequest.auth_token)
}

// optional string device_id = 6;
inline bool LoginRequest::has_device_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LoginRequest::set_has_device_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LoginRequest::clear_has_device_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LoginRequest::clear_device_id() {
  device_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_device_id();
}
inline const ::std::string& LoginRequest::device_id() const {
  // @@protoc_insertion_point(field_get:mcs_proto.LoginRequest.device_id)
  return device_id_.GetNoArena();
}
inline void LoginRequest::set_device_id(const ::std::string& value) {
  set_has_device_id();
  device_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcs_proto.LoginRequest.device_id)
}
#if LANG_CXX11
inline void LoginRequest::set_device_id(::std::string&& value) {
  set_has_device_id();
  device_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcs_proto.LoginRequest.device_id)
}
#endif
inline void LoginRequest::set_device_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_device_id();
  device_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcs_proto.LoginRequest.device_id)
}
inline void LoginRequest::set_device_id(const char* value, size_t size) {
  set_has_device_id();
  device_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcs_proto.LoginRequest.device_id)
}
inline ::std::string* LoginRequest::mutable_device_id() {
  set_has_device_id();
  // @@protoc_insertion_point(field_mutable:mcs_proto.LoginRequest.device_id)
  return device_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginRequest::release_device_id() {
  // @@protoc_insertion_point(field_release:mcs_proto.LoginRequest.device_id)
  clear_has_device_id();
  return device_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginRequest::set_allocated_device_id(::std::string* device_id) {
  if (device_id != NULL) {
    set_has_device_id();
  } else {
    clear_has_device_id();
  }
  device_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), device_id);
  // @@protoc_insertion_point(field_set_allocated:mcs_proto.LoginRequest.device_id)
}

// optional int64 last_rmq_id = 7;
inline bool LoginRequest::has_last_rmq_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LoginRequest::set_has_last_rmq_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LoginRequest::clear_has_last_rmq_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LoginRequest::clear_last_rmq_id() {
  last_rmq_id_ = GOOGLE_LONGLONG(0);
  clear_has_last_rmq_id();
}
inline ::google::protobuf::int64 LoginRequest::last_rmq_id() const {
  // @@protoc_insertion_point(field_get:mcs_proto.LoginRequest.last_rmq_id)
  return last_rmq_id_;
}
inline void LoginRequest::set_last_rmq_id(::google::protobuf::int64 value) {
  set_has_last_rmq_id();
  last_rmq_id_ = value;
  // @@protoc_insertion_point(field_set:mcs_proto.LoginRequest.last_rmq_id)
}

// repeated .mcs_proto.Setting setting = 8;
inline int LoginRequest::setting_size() const {
  return setting_.size();
}
inline void LoginRequest::clear_setting() {
  setting_.Clear();
}
inline const ::mcs_proto::Setting& LoginRequest::setting(int index) const {
  // @@protoc_insertion_point(field_get:mcs_proto.LoginRequest.setting)
  return setting_.Get(index);
}
inline ::mcs_proto::Setting* LoginRequest::mutable_setting(int index) {
  // @@protoc_insertion_point(field_mutable:mcs_proto.LoginRequest.setting)
  return setting_.Mutable(index);
}
inline ::mcs_proto::Setting* LoginRequest::add_setting() {
  // @@protoc_insertion_point(field_add:mcs_proto.LoginRequest.setting)
  return setting_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mcs_proto::Setting >*
LoginRequest::mutable_setting() {
  // @@protoc_insertion_point(field_mutable_list:mcs_proto.LoginRequest.setting)
  return &setting_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mcs_proto::Setting >&
LoginRequest::setting() const {
  // @@protoc_insertion_point(field_list:mcs_proto.LoginRequest.setting)
  return setting_;
}

// repeated string received_persistent_id = 10;
inline int LoginRequest::received_persistent_id_size() const {
  return received_persistent_id_.size();
}
inline void LoginRequest::clear_received_persistent_id() {
  received_persistent_id_.Clear();
}
inline const ::std::string& LoginRequest::received_persistent_id(int index) const {
  // @@protoc_insertion_point(field_get:mcs_proto.LoginRequest.received_persistent_id)
  return received_persistent_id_.Get(index);
}
inline ::std::string* LoginRequest::mutable_received_persistent_id(int index) {
  // @@protoc_insertion_point(field_mutable:mcs_proto.LoginRequest.received_persistent_id)
  return received_persistent_id_.Mutable(index);
}
inline void LoginRequest::set_received_persistent_id(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:mcs_proto.LoginRequest.received_persistent_id)
  received_persistent_id_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void LoginRequest::set_received_persistent_id(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:mcs_proto.LoginRequest.received_persistent_id)
  received_persistent_id_.Mutable(index)->assign(std::move(value));
}
#endif
inline void LoginRequest::set_received_persistent_id(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  received_persistent_id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mcs_proto.LoginRequest.received_persistent_id)
}
inline void LoginRequest::set_received_persistent_id(int index, const char* value, size_t size) {
  received_persistent_id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mcs_proto.LoginRequest.received_persistent_id)
}
inline ::std::string* LoginRequest::add_received_persistent_id() {
  // @@protoc_insertion_point(field_add_mutable:mcs_proto.LoginRequest.received_persistent_id)
  return received_persistent_id_.Add();
}
inline void LoginRequest::add_received_persistent_id(const ::std::string& value) {
  received_persistent_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:mcs_proto.LoginRequest.received_persistent_id)
}
#if LANG_CXX11
inline void LoginRequest::add_received_persistent_id(::std::string&& value) {
  received_persistent_id_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:mcs_proto.LoginRequest.received_persistent_id)
}
#endif
inline void LoginRequest::add_received_persistent_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  received_persistent_id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mcs_proto.LoginRequest.received_persistent_id)
}
inline void LoginRequest::add_received_persistent_id(const char* value, size_t size) {
  received_persistent_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mcs_proto.LoginRequest.received_persistent_id)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
LoginRequest::received_persistent_id() const {
  // @@protoc_insertion_point(field_list:mcs_proto.LoginRequest.received_persistent_id)
  return received_persistent_id_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
LoginRequest::mutable_received_persistent_id() {
  // @@protoc_insertion_point(field_mutable_list:mcs_proto.LoginRequest.received_persistent_id)
  return &received_persistent_id_;
}

// optional bool adaptive_heartbeat = 12;
inline bool LoginRequest::has_adaptive_heartbeat() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void LoginRequest::set_has_adaptive_heartbeat() {
  _has_bits_[0] |= 0x00000100u;
}
inline void LoginRequest::clear_has_adaptive_heartbeat() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void LoginRequest::clear_adaptive_heartbeat() {
  adaptive_heartbeat_ = false;
  clear_has_adaptive_heartbeat();
}
inline bool LoginRequest::adaptive_heartbeat() const {
  // @@protoc_insertion_point(field_get:mcs_proto.LoginRequest.adaptive_heartbeat)
  return adaptive_heartbeat_;
}
inline void LoginRequest::set_adaptive_heartbeat(bool value) {
  set_has_adaptive_heartbeat();
  adaptive_heartbeat_ = value;
  // @@protoc_insertion_point(field_set:mcs_proto.LoginRequest.adaptive_heartbeat)
}

// optional .mcs_proto.HeartbeatStat heartbeat_stat = 13;
inline bool LoginRequest::has_heartbeat_stat() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LoginRequest::set_has_heartbeat_stat() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LoginRequest::clear_has_heartbeat_stat() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LoginRequest::clear_heartbeat_stat() {
  if (heartbeat_stat_ != NULL) heartbeat_stat_->Clear();
  clear_has_heartbeat_stat();
}
inline const ::mcs_proto::HeartbeatStat& LoginRequest::heartbeat_stat() const {
  const ::mcs_proto::HeartbeatStat* p = heartbeat_stat_;
  // @@protoc_insertion_point(field_get:mcs_proto.LoginRequest.heartbeat_stat)
  return p != NULL ? *p : *reinterpret_cast<const ::mcs_proto::HeartbeatStat*>(
      &::mcs_proto::_HeartbeatStat_default_instance_);
}
inline ::mcs_proto::HeartbeatStat* LoginRequest::release_heartbeat_stat() {
  // @@protoc_insertion_point(field_release:mcs_proto.LoginRequest.heartbeat_stat)
  clear_has_heartbeat_stat();
  ::mcs_proto::HeartbeatStat* temp = heartbeat_stat_;
  heartbeat_stat_ = NULL;
  return temp;
}
inline ::mcs_proto::HeartbeatStat* LoginRequest::mutable_heartbeat_stat() {
  set_has_heartbeat_stat();
  if (heartbeat_stat_ == NULL) {
    heartbeat_stat_ = new ::mcs_proto::HeartbeatStat;
  }
  // @@protoc_insertion_point(field_mutable:mcs_proto.LoginRequest.heartbeat_stat)
  return heartbeat_stat_;
}
inline void LoginRequest::set_allocated_heartbeat_stat(::mcs_proto::HeartbeatStat* heartbeat_stat) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete heartbeat_stat_;
  }
  if (heartbeat_stat) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      heartbeat_stat = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, heartbeat_stat, submessage_arena);
    }
    set_has_heartbeat_stat();
  } else {
    clear_has_heartbeat_stat();
  }
  heartbeat_stat_ = heartbeat_stat;
  // @@protoc_insertion_point(field_set_allocated:mcs_proto.LoginRequest.heartbeat_stat)
}

// optional bool use_rmq2 = 14;
inline bool LoginRequest::has_use_rmq2() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void LoginRequest::set_has_use_rmq2() {
  _has_bits_[0] |= 0x00000200u;
}
inline void LoginRequest::clear_has_use_rmq2() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void LoginRequest::clear_use_rmq2() {
  use_rmq2_ = false;
  clear_has_use_rmq2();
}
inline bool LoginRequest::use_rmq2() const {
  // @@protoc_insertion_point(field_get:mcs_proto.LoginRequest.use_rmq2)
  return use_rmq2_;
}
inline void LoginRequest::set_use_rmq2(bool value) {
  set_has_use_rmq2();
  use_rmq2_ = value;
  // @@protoc_insertion_point(field_set:mcs_proto.LoginRequest.use_rmq2)
}

// optional int64 account_id = 15;
inline bool LoginRequest::has_account_id() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void LoginRequest::set_has_account_id() {
  _has_bits_[0] |= 0x00000800u;
}
inline void LoginRequest::clear_has_account_id() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void LoginRequest::clear_account_id() {
  account_id_ = GOOGLE_LONGLONG(0);
  clear_has_account_id();
}
inline ::google::protobuf::int64 LoginRequest::account_id() const {
  // @@protoc_insertion_point(field_get:mcs_proto.LoginRequest.account_id)
  return account_id_;
}
inline void LoginRequest::set_account_id(::google::protobuf::int64 value) {
  set_has_account_id();
  account_id_ = value;
  // @@protoc_insertion_point(field_set:mcs_proto.LoginRequest.account_id)
}

// optional .mcs_proto.LoginRequest.AuthService auth_service = 16;
inline bool LoginRequest::has_auth_service() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void LoginRequest::set_has_auth_service() {
  _has_bits_[0] |= 0x00002000u;
}
inline void LoginRequest::clear_has_auth_service() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void LoginRequest::clear_auth_service() {
  auth_service_ = 2;
  clear_has_auth_service();
}
inline ::mcs_proto::LoginRequest_AuthService LoginRequest::auth_service() const {
  // @@protoc_insertion_point(field_get:mcs_proto.LoginRequest.auth_service)
  return static_cast< ::mcs_proto::LoginRequest_AuthService >(auth_service_);
}
inline void LoginRequest::set_auth_service(::mcs_proto::LoginRequest_AuthService value) {
  assert(::mcs_proto::LoginRequest_AuthService_IsValid(value));
  set_has_auth_service();
  auth_service_ = value;
  // @@protoc_insertion_point(field_set:mcs_proto.LoginRequest.auth_service)
}

// optional int32 network_type = 17;
inline bool LoginRequest::has_network_type() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void LoginRequest::set_has_network_type() {
  _has_bits_[0] |= 0x00000400u;
}
inline void LoginRequest::clear_has_network_type() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void LoginRequest::clear_network_type() {
  network_type_ = 0;
  clear_has_network_type();
}
inline ::google::protobuf::int32 LoginRequest::network_type() const {
  // @@protoc_insertion_point(field_get:mcs_proto.LoginRequest.network_type)
  return network_type_;
}
inline void LoginRequest::set_network_type(::google::protobuf::int32 value) {
  set_has_network_type();
  network_type_ = value;
  // @@protoc_insertion_point(field_set:mcs_proto.LoginRequest.network_type)
}

// optional int64 status = 18;
inline bool LoginRequest::has_status() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void LoginRequest::set_has_status() {
  _has_bits_[0] |= 0x00001000u;
}
inline void LoginRequest::clear_has_status() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void LoginRequest::clear_status() {
  status_ = GOOGLE_LONGLONG(0);
  clear_has_status();
}
inline ::google::protobuf::int64 LoginRequest::status() const {
  // @@protoc_insertion_point(field_get:mcs_proto.LoginRequest.status)
  return status_;
}
inline void LoginRequest::set_status(::google::protobuf::int64 value) {
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:mcs_proto.LoginRequest.status)
}

// repeated .mcs_proto.ClientEvent client_event = 22;
inline int LoginRequest::client_event_size() const {
  return client_event_.size();
}
inline void LoginRequest::clear_client_event() {
  client_event_.Clear();
}
inline const ::mcs_proto::ClientEvent& LoginRequest::client_event(int index) const {
  // @@protoc_insertion_point(field_get:mcs_proto.LoginRequest.client_event)
  return client_event_.Get(index);
}
inline ::mcs_proto::ClientEvent* LoginRequest::mutable_client_event(int index) {
  // @@protoc_insertion_point(field_mutable:mcs_proto.LoginRequest.client_event)
  return client_event_.Mutable(index);
}
inline ::mcs_proto::ClientEvent* LoginRequest::add_client_event() {
  // @@protoc_insertion_point(field_add:mcs_proto.LoginRequest.client_event)
  return client_event_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mcs_proto::ClientEvent >*
LoginRequest::mutable_client_event() {
  // @@protoc_insertion_point(field_mutable_list:mcs_proto.LoginRequest.client_event)
  return &client_event_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mcs_proto::ClientEvent >&
LoginRequest::client_event() const {
  // @@protoc_insertion_point(field_list:mcs_proto.LoginRequest.client_event)
  return client_event_;
}

// -------------------------------------------------------------------

// LoginResponse

// required string id = 1;
inline bool LoginResponse::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginResponse::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginResponse::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginResponse::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& LoginResponse::id() const {
  // @@protoc_insertion_point(field_get:mcs_proto.LoginResponse.id)
  return id_.GetNoArena();
}
inline void LoginResponse::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcs_proto.LoginResponse.id)
}
#if LANG_CXX11
inline void LoginResponse::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcs_proto.LoginResponse.id)
}
#endif
inline void LoginResponse::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcs_proto.LoginResponse.id)
}
inline void LoginResponse::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcs_proto.LoginResponse.id)
}
inline ::std::string* LoginResponse::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:mcs_proto.LoginResponse.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginResponse::release_id() {
  // @@protoc_insertion_point(field_release:mcs_proto.LoginResponse.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginResponse::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:mcs_proto.LoginResponse.id)
}

// optional string jid = 2;
inline bool LoginResponse::has_jid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginResponse::set_has_jid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginResponse::clear_has_jid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginResponse::clear_jid() {
  jid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_jid();
}
inline const ::std::string& LoginResponse::jid() const {
  // @@protoc_insertion_point(field_get:mcs_proto.LoginResponse.jid)
  return jid_.GetNoArena();
}
inline void LoginResponse::set_jid(const ::std::string& value) {
  set_has_jid();
  jid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcs_proto.LoginResponse.jid)
}
#if LANG_CXX11
inline void LoginResponse::set_jid(::std::string&& value) {
  set_has_jid();
  jid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcs_proto.LoginResponse.jid)
}
#endif
inline void LoginResponse::set_jid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_jid();
  jid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcs_proto.LoginResponse.jid)
}
inline void LoginResponse::set_jid(const char* value, size_t size) {
  set_has_jid();
  jid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcs_proto.LoginResponse.jid)
}
inline ::std::string* LoginResponse::mutable_jid() {
  set_has_jid();
  // @@protoc_insertion_point(field_mutable:mcs_proto.LoginResponse.jid)
  return jid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginResponse::release_jid() {
  // @@protoc_insertion_point(field_release:mcs_proto.LoginResponse.jid)
  clear_has_jid();
  return jid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginResponse::set_allocated_jid(::std::string* jid) {
  if (jid != NULL) {
    set_has_jid();
  } else {
    clear_has_jid();
  }
  jid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), jid);
  // @@protoc_insertion_point(field_set_allocated:mcs_proto.LoginResponse.jid)
}

// optional .mcs_proto.ErrorInfo error = 3;
inline bool LoginResponse::has_error() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginResponse::set_has_error() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginResponse::clear_has_error() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginResponse::clear_error() {
  if (error_ != NULL) error_->Clear();
  clear_has_error();
}
inline const ::mcs_proto::ErrorInfo& LoginResponse::error() const {
  const ::mcs_proto::ErrorInfo* p = error_;
  // @@protoc_insertion_point(field_get:mcs_proto.LoginResponse.error)
  return p != NULL ? *p : *reinterpret_cast<const ::mcs_proto::ErrorInfo*>(
      &::mcs_proto::_ErrorInfo_default_instance_);
}
inline ::mcs_proto::ErrorInfo* LoginResponse::release_error() {
  // @@protoc_insertion_point(field_release:mcs_proto.LoginResponse.error)
  clear_has_error();
  ::mcs_proto::ErrorInfo* temp = error_;
  error_ = NULL;
  return temp;
}
inline ::mcs_proto::ErrorInfo* LoginResponse::mutable_error() {
  set_has_error();
  if (error_ == NULL) {
    error_ = new ::mcs_proto::ErrorInfo;
  }
  // @@protoc_insertion_point(field_mutable:mcs_proto.LoginResponse.error)
  return error_;
}
inline void LoginResponse::set_allocated_error(::mcs_proto::ErrorInfo* error) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete error_;
  }
  if (error) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      error = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    set_has_error();
  } else {
    clear_has_error();
  }
  error_ = error;
  // @@protoc_insertion_point(field_set_allocated:mcs_proto.LoginResponse.error)
}

// repeated .mcs_proto.Setting setting = 4;
inline int LoginResponse::setting_size() const {
  return setting_.size();
}
inline void LoginResponse::clear_setting() {
  setting_.Clear();
}
inline const ::mcs_proto::Setting& LoginResponse::setting(int index) const {
  // @@protoc_insertion_point(field_get:mcs_proto.LoginResponse.setting)
  return setting_.Get(index);
}
inline ::mcs_proto::Setting* LoginResponse::mutable_setting(int index) {
  // @@protoc_insertion_point(field_mutable:mcs_proto.LoginResponse.setting)
  return setting_.Mutable(index);
}
inline ::mcs_proto::Setting* LoginResponse::add_setting() {
  // @@protoc_insertion_point(field_add:mcs_proto.LoginResponse.setting)
  return setting_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mcs_proto::Setting >*
LoginResponse::mutable_setting() {
  // @@protoc_insertion_point(field_mutable_list:mcs_proto.LoginResponse.setting)
  return &setting_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mcs_proto::Setting >&
LoginResponse::setting() const {
  // @@protoc_insertion_point(field_list:mcs_proto.LoginResponse.setting)
  return setting_;
}

// optional int32 stream_id = 5;
inline bool LoginResponse::has_stream_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LoginResponse::set_has_stream_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LoginResponse::clear_has_stream_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LoginResponse::clear_stream_id() {
  stream_id_ = 0;
  clear_has_stream_id();
}
inline ::google::protobuf::int32 LoginResponse::stream_id() const {
  // @@protoc_insertion_point(field_get:mcs_proto.LoginResponse.stream_id)
  return stream_id_;
}
inline void LoginResponse::set_stream_id(::google::protobuf::int32 value) {
  set_has_stream_id();
  stream_id_ = value;
  // @@protoc_insertion_point(field_set:mcs_proto.LoginResponse.stream_id)
}

// optional int32 last_stream_id_received = 6;
inline bool LoginResponse::has_last_stream_id_received() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LoginResponse::set_has_last_stream_id_received() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LoginResponse::clear_has_last_stream_id_received() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LoginResponse::clear_last_stream_id_received() {
  last_stream_id_received_ = 0;
  clear_has_last_stream_id_received();
}
inline ::google::protobuf::int32 LoginResponse::last_stream_id_received() const {
  // @@protoc_insertion_point(field_get:mcs_proto.LoginResponse.last_stream_id_received)
  return last_stream_id_received_;
}
inline void LoginResponse::set_last_stream_id_received(::google::protobuf::int32 value) {
  set_has_last_stream_id_received();
  last_stream_id_received_ = value;
  // @@protoc_insertion_point(field_set:mcs_proto.LoginResponse.last_stream_id_received)
}

// optional .mcs_proto.HeartbeatConfig heartbeat_config = 7;
inline bool LoginResponse::has_heartbeat_config() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoginResponse::set_has_heartbeat_config() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoginResponse::clear_has_heartbeat_config() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoginResponse::clear_heartbeat_config() {
  if (heartbeat_config_ != NULL) heartbeat_config_->Clear();
  clear_has_heartbeat_config();
}
inline const ::mcs_proto::HeartbeatConfig& LoginResponse::heartbeat_config() const {
  const ::mcs_proto::HeartbeatConfig* p = heartbeat_config_;
  // @@protoc_insertion_point(field_get:mcs_proto.LoginResponse.heartbeat_config)
  return p != NULL ? *p : *reinterpret_cast<const ::mcs_proto::HeartbeatConfig*>(
      &::mcs_proto::_HeartbeatConfig_default_instance_);
}
inline ::mcs_proto::HeartbeatConfig* LoginResponse::release_heartbeat_config() {
  // @@protoc_insertion_point(field_release:mcs_proto.LoginResponse.heartbeat_config)
  clear_has_heartbeat_config();
  ::mcs_proto::HeartbeatConfig* temp = heartbeat_config_;
  heartbeat_config_ = NULL;
  return temp;
}
inline ::mcs_proto::HeartbeatConfig* LoginResponse::mutable_heartbeat_config() {
  set_has_heartbeat_config();
  if (heartbeat_config_ == NULL) {
    heartbeat_config_ = new ::mcs_proto::HeartbeatConfig;
  }
  // @@protoc_insertion_point(field_mutable:mcs_proto.LoginResponse.heartbeat_config)
  return heartbeat_config_;
}
inline void LoginResponse::set_allocated_heartbeat_config(::mcs_proto::HeartbeatConfig* heartbeat_config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete heartbeat_config_;
  }
  if (heartbeat_config) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      heartbeat_config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, heartbeat_config, submessage_arena);
    }
    set_has_heartbeat_config();
  } else {
    clear_has_heartbeat_config();
  }
  heartbeat_config_ = heartbeat_config;
  // @@protoc_insertion_point(field_set_allocated:mcs_proto.LoginResponse.heartbeat_config)
}

// optional int64 server_timestamp = 8;
inline bool LoginResponse::has_server_timestamp() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LoginResponse::set_has_server_timestamp() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LoginResponse::clear_has_server_timestamp() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LoginResponse::clear_server_timestamp() {
  server_timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_server_timestamp();
}
inline ::google::protobuf::int64 LoginResponse::server_timestamp() const {
  // @@protoc_insertion_point(field_get:mcs_proto.LoginResponse.server_timestamp)
  return server_timestamp_;
}
inline void LoginResponse::set_server_timestamp(::google::protobuf::int64 value) {
  set_has_server_timestamp();
  server_timestamp_ = value;
  // @@protoc_insertion_point(field_set:mcs_proto.LoginResponse.server_timestamp)
}

// -------------------------------------------------------------------

// StreamErrorStanza

// required string type = 1;
inline bool StreamErrorStanza::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StreamErrorStanza::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StreamErrorStanza::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StreamErrorStanza::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_type();
}
inline const ::std::string& StreamErrorStanza::type() const {
  // @@protoc_insertion_point(field_get:mcs_proto.StreamErrorStanza.type)
  return type_.GetNoArena();
}
inline void StreamErrorStanza::set_type(const ::std::string& value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcs_proto.StreamErrorStanza.type)
}
#if LANG_CXX11
inline void StreamErrorStanza::set_type(::std::string&& value) {
  set_has_type();
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcs_proto.StreamErrorStanza.type)
}
#endif
inline void StreamErrorStanza::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcs_proto.StreamErrorStanza.type)
}
inline void StreamErrorStanza::set_type(const char* value, size_t size) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcs_proto.StreamErrorStanza.type)
}
inline ::std::string* StreamErrorStanza::mutable_type() {
  set_has_type();
  // @@protoc_insertion_point(field_mutable:mcs_proto.StreamErrorStanza.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StreamErrorStanza::release_type() {
  // @@protoc_insertion_point(field_release:mcs_proto.StreamErrorStanza.type)
  clear_has_type();
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StreamErrorStanza::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    set_has_type();
  } else {
    clear_has_type();
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:mcs_proto.StreamErrorStanza.type)
}

// optional string text = 2;
inline bool StreamErrorStanza::has_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StreamErrorStanza::set_has_text() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StreamErrorStanza::clear_has_text() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StreamErrorStanza::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_text();
}
inline const ::std::string& StreamErrorStanza::text() const {
  // @@protoc_insertion_point(field_get:mcs_proto.StreamErrorStanza.text)
  return text_.GetNoArena();
}
inline void StreamErrorStanza::set_text(const ::std::string& value) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcs_proto.StreamErrorStanza.text)
}
#if LANG_CXX11
inline void StreamErrorStanza::set_text(::std::string&& value) {
  set_has_text();
  text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcs_proto.StreamErrorStanza.text)
}
#endif
inline void StreamErrorStanza::set_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcs_proto.StreamErrorStanza.text)
}
inline void StreamErrorStanza::set_text(const char* value, size_t size) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcs_proto.StreamErrorStanza.text)
}
inline ::std::string* StreamErrorStanza::mutable_text() {
  set_has_text();
  // @@protoc_insertion_point(field_mutable:mcs_proto.StreamErrorStanza.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StreamErrorStanza::release_text() {
  // @@protoc_insertion_point(field_release:mcs_proto.StreamErrorStanza.text)
  clear_has_text();
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StreamErrorStanza::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    set_has_text();
  } else {
    clear_has_text();
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:mcs_proto.StreamErrorStanza.text)
}

// -------------------------------------------------------------------

// Close

// -------------------------------------------------------------------

// Extension

// required int32 id = 1;
inline bool Extension::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Extension::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Extension::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Extension::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Extension::id() const {
  // @@protoc_insertion_point(field_get:mcs_proto.Extension.id)
  return id_;
}
inline void Extension::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:mcs_proto.Extension.id)
}

// required bytes data = 2;
inline bool Extension::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Extension::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Extension::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Extension::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data();
}
inline const ::std::string& Extension::data() const {
  // @@protoc_insertion_point(field_get:mcs_proto.Extension.data)
  return data_.GetNoArena();
}
inline void Extension::set_data(const ::std::string& value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcs_proto.Extension.data)
}
#if LANG_CXX11
inline void Extension::set_data(::std::string&& value) {
  set_has_data();
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcs_proto.Extension.data)
}
#endif
inline void Extension::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcs_proto.Extension.data)
}
inline void Extension::set_data(const void* value, size_t size) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcs_proto.Extension.data)
}
inline ::std::string* Extension::mutable_data() {
  set_has_data();
  // @@protoc_insertion_point(field_mutable:mcs_proto.Extension.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Extension::release_data() {
  // @@protoc_insertion_point(field_release:mcs_proto.Extension.data)
  clear_has_data();
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Extension::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:mcs_proto.Extension.data)
}

// -------------------------------------------------------------------

// IqStanza

// optional int64 rmq_id = 1;
inline bool IqStanza::has_rmq_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void IqStanza::set_has_rmq_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void IqStanza::clear_has_rmq_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void IqStanza::clear_rmq_id() {
  rmq_id_ = GOOGLE_LONGLONG(0);
  clear_has_rmq_id();
}
inline ::google::protobuf::int64 IqStanza::rmq_id() const {
  // @@protoc_insertion_point(field_get:mcs_proto.IqStanza.rmq_id)
  return rmq_id_;
}
inline void IqStanza::set_rmq_id(::google::protobuf::int64 value) {
  set_has_rmq_id();
  rmq_id_ = value;
  // @@protoc_insertion_point(field_set:mcs_proto.IqStanza.rmq_id)
}

// required .mcs_proto.IqStanza.IqType type = 2;
inline bool IqStanza::has_type() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void IqStanza::set_has_type() {
  _has_bits_[0] |= 0x00000080u;
}
inline void IqStanza::clear_has_type() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void IqStanza::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mcs_proto::IqStanza_IqType IqStanza::type() const {
  // @@protoc_insertion_point(field_get:mcs_proto.IqStanza.type)
  return static_cast< ::mcs_proto::IqStanza_IqType >(type_);
}
inline void IqStanza::set_type(::mcs_proto::IqStanza_IqType value) {
  assert(::mcs_proto::IqStanza_IqType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mcs_proto.IqStanza.type)
}

// required string id = 3;
inline bool IqStanza::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IqStanza::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IqStanza::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IqStanza::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& IqStanza::id() const {
  // @@protoc_insertion_point(field_get:mcs_proto.IqStanza.id)
  return id_.GetNoArena();
}
inline void IqStanza::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcs_proto.IqStanza.id)
}
#if LANG_CXX11
inline void IqStanza::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcs_proto.IqStanza.id)
}
#endif
inline void IqStanza::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcs_proto.IqStanza.id)
}
inline void IqStanza::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcs_proto.IqStanza.id)
}
inline ::std::string* IqStanza::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:mcs_proto.IqStanza.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IqStanza::release_id() {
  // @@protoc_insertion_point(field_release:mcs_proto.IqStanza.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IqStanza::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:mcs_proto.IqStanza.id)
}

// optional string from = 4;
inline bool IqStanza::has_from() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IqStanza::set_has_from() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IqStanza::clear_has_from() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IqStanza::clear_from() {
  from_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_from();
}
inline const ::std::string& IqStanza::from() const {
  // @@protoc_insertion_point(field_get:mcs_proto.IqStanza.from)
  return from_.GetNoArena();
}
inline void IqStanza::set_from(const ::std::string& value) {
  set_has_from();
  from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcs_proto.IqStanza.from)
}
#if LANG_CXX11
inline void IqStanza::set_from(::std::string&& value) {
  set_has_from();
  from_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcs_proto.IqStanza.from)
}
#endif
inline void IqStanza::set_from(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_from();
  from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcs_proto.IqStanza.from)
}
inline void IqStanza::set_from(const char* value, size_t size) {
  set_has_from();
  from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcs_proto.IqStanza.from)
}
inline ::std::string* IqStanza::mutable_from() {
  set_has_from();
  // @@protoc_insertion_point(field_mutable:mcs_proto.IqStanza.from)
  return from_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IqStanza::release_from() {
  // @@protoc_insertion_point(field_release:mcs_proto.IqStanza.from)
  clear_has_from();
  return from_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IqStanza::set_allocated_from(::std::string* from) {
  if (from != NULL) {
    set_has_from();
  } else {
    clear_has_from();
  }
  from_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from);
  // @@protoc_insertion_point(field_set_allocated:mcs_proto.IqStanza.from)
}

// optional string to = 5;
inline bool IqStanza::has_to() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IqStanza::set_has_to() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IqStanza::clear_has_to() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IqStanza::clear_to() {
  to_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_to();
}
inline const ::std::string& IqStanza::to() const {
  // @@protoc_insertion_point(field_get:mcs_proto.IqStanza.to)
  return to_.GetNoArena();
}
inline void IqStanza::set_to(const ::std::string& value) {
  set_has_to();
  to_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcs_proto.IqStanza.to)
}
#if LANG_CXX11
inline void IqStanza::set_to(::std::string&& value) {
  set_has_to();
  to_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcs_proto.IqStanza.to)
}
#endif
inline void IqStanza::set_to(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_to();
  to_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcs_proto.IqStanza.to)
}
inline void IqStanza::set_to(const char* value, size_t size) {
  set_has_to();
  to_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcs_proto.IqStanza.to)
}
inline ::std::string* IqStanza::mutable_to() {
  set_has_to();
  // @@protoc_insertion_point(field_mutable:mcs_proto.IqStanza.to)
  return to_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IqStanza::release_to() {
  // @@protoc_insertion_point(field_release:mcs_proto.IqStanza.to)
  clear_has_to();
  return to_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IqStanza::set_allocated_to(::std::string* to) {
  if (to != NULL) {
    set_has_to();
  } else {
    clear_has_to();
  }
  to_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), to);
  // @@protoc_insertion_point(field_set_allocated:mcs_proto.IqStanza.to)
}

// optional .mcs_proto.ErrorInfo error = 6;
inline bool IqStanza::has_error() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IqStanza::set_has_error() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IqStanza::clear_has_error() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IqStanza::clear_error() {
  if (error_ != NULL) error_->Clear();
  clear_has_error();
}
inline const ::mcs_proto::ErrorInfo& IqStanza::error() const {
  const ::mcs_proto::ErrorInfo* p = error_;
  // @@protoc_insertion_point(field_get:mcs_proto.IqStanza.error)
  return p != NULL ? *p : *reinterpret_cast<const ::mcs_proto::ErrorInfo*>(
      &::mcs_proto::_ErrorInfo_default_instance_);
}
inline ::mcs_proto::ErrorInfo* IqStanza::release_error() {
  // @@protoc_insertion_point(field_release:mcs_proto.IqStanza.error)
  clear_has_error();
  ::mcs_proto::ErrorInfo* temp = error_;
  error_ = NULL;
  return temp;
}
inline ::mcs_proto::ErrorInfo* IqStanza::mutable_error() {
  set_has_error();
  if (error_ == NULL) {
    error_ = new ::mcs_proto::ErrorInfo;
  }
  // @@protoc_insertion_point(field_mutable:mcs_proto.IqStanza.error)
  return error_;
}
inline void IqStanza::set_allocated_error(::mcs_proto::ErrorInfo* error) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete error_;
  }
  if (error) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      error = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    set_has_error();
  } else {
    clear_has_error();
  }
  error_ = error;
  // @@protoc_insertion_point(field_set_allocated:mcs_proto.IqStanza.error)
}

// optional .mcs_proto.Extension extension = 7;
inline bool IqStanza::has_extension() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void IqStanza::set_has_extension() {
  _has_bits_[0] |= 0x00000020u;
}
inline void IqStanza::clear_has_extension() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void IqStanza::clear_extension() {
  if (extension_ != NULL) extension_->Clear();
  clear_has_extension();
}
inline const ::mcs_proto::Extension& IqStanza::extension() const {
  const ::mcs_proto::Extension* p = extension_;
  // @@protoc_insertion_point(field_get:mcs_proto.IqStanza.extension)
  return p != NULL ? *p : *reinterpret_cast<const ::mcs_proto::Extension*>(
      &::mcs_proto::_Extension_default_instance_);
}
inline ::mcs_proto::Extension* IqStanza::release_extension() {
  // @@protoc_insertion_point(field_release:mcs_proto.IqStanza.extension)
  clear_has_extension();
  ::mcs_proto::Extension* temp = extension_;
  extension_ = NULL;
  return temp;
}
inline ::mcs_proto::Extension* IqStanza::mutable_extension() {
  set_has_extension();
  if (extension_ == NULL) {
    extension_ = new ::mcs_proto::Extension;
  }
  // @@protoc_insertion_point(field_mutable:mcs_proto.IqStanza.extension)
  return extension_;
}
inline void IqStanza::set_allocated_extension(::mcs_proto::Extension* extension) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete extension_;
  }
  if (extension) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      extension = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, extension, submessage_arena);
    }
    set_has_extension();
  } else {
    clear_has_extension();
  }
  extension_ = extension;
  // @@protoc_insertion_point(field_set_allocated:mcs_proto.IqStanza.extension)
}

// optional string persistent_id = 8;
inline bool IqStanza::has_persistent_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IqStanza::set_has_persistent_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IqStanza::clear_has_persistent_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IqStanza::clear_persistent_id() {
  persistent_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_persistent_id();
}
inline const ::std::string& IqStanza::persistent_id() const {
  // @@protoc_insertion_point(field_get:mcs_proto.IqStanza.persistent_id)
  return persistent_id_.GetNoArena();
}
inline void IqStanza::set_persistent_id(const ::std::string& value) {
  set_has_persistent_id();
  persistent_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcs_proto.IqStanza.persistent_id)
}
#if LANG_CXX11
inline void IqStanza::set_persistent_id(::std::string&& value) {
  set_has_persistent_id();
  persistent_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcs_proto.IqStanza.persistent_id)
}
#endif
inline void IqStanza::set_persistent_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_persistent_id();
  persistent_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcs_proto.IqStanza.persistent_id)
}
inline void IqStanza::set_persistent_id(const char* value, size_t size) {
  set_has_persistent_id();
  persistent_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcs_proto.IqStanza.persistent_id)
}
inline ::std::string* IqStanza::mutable_persistent_id() {
  set_has_persistent_id();
  // @@protoc_insertion_point(field_mutable:mcs_proto.IqStanza.persistent_id)
  return persistent_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IqStanza::release_persistent_id() {
  // @@protoc_insertion_point(field_release:mcs_proto.IqStanza.persistent_id)
  clear_has_persistent_id();
  return persistent_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IqStanza::set_allocated_persistent_id(::std::string* persistent_id) {
  if (persistent_id != NULL) {
    set_has_persistent_id();
  } else {
    clear_has_persistent_id();
  }
  persistent_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), persistent_id);
  // @@protoc_insertion_point(field_set_allocated:mcs_proto.IqStanza.persistent_id)
}

// optional int32 stream_id = 9;
inline bool IqStanza::has_stream_id() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void IqStanza::set_has_stream_id() {
  _has_bits_[0] |= 0x00000100u;
}
inline void IqStanza::clear_has_stream_id() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void IqStanza::clear_stream_id() {
  stream_id_ = 0;
  clear_has_stream_id();
}
inline ::google::protobuf::int32 IqStanza::stream_id() const {
  // @@protoc_insertion_point(field_get:mcs_proto.IqStanza.stream_id)
  return stream_id_;
}
inline void IqStanza::set_stream_id(::google::protobuf::int32 value) {
  set_has_stream_id();
  stream_id_ = value;
  // @@protoc_insertion_point(field_set:mcs_proto.IqStanza.stream_id)
}

// optional int32 last_stream_id_received = 10;
inline bool IqStanza::has_last_stream_id_received() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void IqStanza::set_has_last_stream_id_received() {
  _has_bits_[0] |= 0x00000800u;
}
inline void IqStanza::clear_has_last_stream_id_received() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void IqStanza::clear_last_stream_id_received() {
  last_stream_id_received_ = 0;
  clear_has_last_stream_id_received();
}
inline ::google::protobuf::int32 IqStanza::last_stream_id_received() const {
  // @@protoc_insertion_point(field_get:mcs_proto.IqStanza.last_stream_id_received)
  return last_stream_id_received_;
}
inline void IqStanza::set_last_stream_id_received(::google::protobuf::int32 value) {
  set_has_last_stream_id_received();
  last_stream_id_received_ = value;
  // @@protoc_insertion_point(field_set:mcs_proto.IqStanza.last_stream_id_received)
}

// optional int64 account_id = 11;
inline bool IqStanza::has_account_id() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void IqStanza::set_has_account_id() {
  _has_bits_[0] |= 0x00000200u;
}
inline void IqStanza::clear_has_account_id() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void IqStanza::clear_account_id() {
  account_id_ = GOOGLE_LONGLONG(0);
  clear_has_account_id();
}
inline ::google::protobuf::int64 IqStanza::account_id() const {
  // @@protoc_insertion_point(field_get:mcs_proto.IqStanza.account_id)
  return account_id_;
}
inline void IqStanza::set_account_id(::google::protobuf::int64 value) {
  set_has_account_id();
  account_id_ = value;
  // @@protoc_insertion_point(field_set:mcs_proto.IqStanza.account_id)
}

// optional int64 status = 12;
inline bool IqStanza::has_status() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void IqStanza::set_has_status() {
  _has_bits_[0] |= 0x00000400u;
}
inline void IqStanza::clear_has_status() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void IqStanza::clear_status() {
  status_ = GOOGLE_LONGLONG(0);
  clear_has_status();
}
inline ::google::protobuf::int64 IqStanza::status() const {
  // @@protoc_insertion_point(field_get:mcs_proto.IqStanza.status)
  return status_;
}
inline void IqStanza::set_status(::google::protobuf::int64 value) {
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:mcs_proto.IqStanza.status)
}

// -------------------------------------------------------------------

// AppData

// required string key = 1;
inline bool AppData::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AppData::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AppData::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AppData::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& AppData::key() const {
  // @@protoc_insertion_point(field_get:mcs_proto.AppData.key)
  return key_.GetNoArena();
}
inline void AppData::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcs_proto.AppData.key)
}
#if LANG_CXX11
inline void AppData::set_key(::std::string&& value) {
  set_has_key();
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcs_proto.AppData.key)
}
#endif
inline void AppData::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcs_proto.AppData.key)
}
inline void AppData::set_key(const char* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcs_proto.AppData.key)
}
inline ::std::string* AppData::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:mcs_proto.AppData.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AppData::release_key() {
  // @@protoc_insertion_point(field_release:mcs_proto.AppData.key)
  clear_has_key();
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AppData::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:mcs_proto.AppData.key)
}

// required string value = 2;
inline bool AppData::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AppData::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AppData::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AppData::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
inline const ::std::string& AppData::value() const {
  // @@protoc_insertion_point(field_get:mcs_proto.AppData.value)
  return value_.GetNoArena();
}
inline void AppData::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcs_proto.AppData.value)
}
#if LANG_CXX11
inline void AppData::set_value(::std::string&& value) {
  set_has_value();
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcs_proto.AppData.value)
}
#endif
inline void AppData::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcs_proto.AppData.value)
}
inline void AppData::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcs_proto.AppData.value)
}
inline ::std::string* AppData::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:mcs_proto.AppData.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AppData::release_value() {
  // @@protoc_insertion_point(field_release:mcs_proto.AppData.value)
  clear_has_value();
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AppData::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:mcs_proto.AppData.value)
}

// -------------------------------------------------------------------

// DataMessageStanza

// optional string id = 2;
inline bool DataMessageStanza::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DataMessageStanza::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DataMessageStanza::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DataMessageStanza::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
inline const ::std::string& DataMessageStanza::id() const {
  // @@protoc_insertion_point(field_get:mcs_proto.DataMessageStanza.id)
  return id_.GetNoArena();
}
inline void DataMessageStanza::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcs_proto.DataMessageStanza.id)
}
#if LANG_CXX11
inline void DataMessageStanza::set_id(::std::string&& value) {
  set_has_id();
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcs_proto.DataMessageStanza.id)
}
#endif
inline void DataMessageStanza::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcs_proto.DataMessageStanza.id)
}
inline void DataMessageStanza::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcs_proto.DataMessageStanza.id)
}
inline ::std::string* DataMessageStanza::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:mcs_proto.DataMessageStanza.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DataMessageStanza::release_id() {
  // @@protoc_insertion_point(field_release:mcs_proto.DataMessageStanza.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DataMessageStanza::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:mcs_proto.DataMessageStanza.id)
}

// required string from = 3;
inline bool DataMessageStanza::has_from() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DataMessageStanza::set_has_from() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DataMessageStanza::clear_has_from() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DataMessageStanza::clear_from() {
  from_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_from();
}
inline const ::std::string& DataMessageStanza::from() const {
  // @@protoc_insertion_point(field_get:mcs_proto.DataMessageStanza.from)
  return from_.GetNoArena();
}
inline void DataMessageStanza::set_from(const ::std::string& value) {
  set_has_from();
  from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcs_proto.DataMessageStanza.from)
}
#if LANG_CXX11
inline void DataMessageStanza::set_from(::std::string&& value) {
  set_has_from();
  from_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcs_proto.DataMessageStanza.from)
}
#endif
inline void DataMessageStanza::set_from(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_from();
  from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcs_proto.DataMessageStanza.from)
}
inline void DataMessageStanza::set_from(const char* value, size_t size) {
  set_has_from();
  from_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcs_proto.DataMessageStanza.from)
}
inline ::std::string* DataMessageStanza::mutable_from() {
  set_has_from();
  // @@protoc_insertion_point(field_mutable:mcs_proto.DataMessageStanza.from)
  return from_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DataMessageStanza::release_from() {
  // @@protoc_insertion_point(field_release:mcs_proto.DataMessageStanza.from)
  clear_has_from();
  return from_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DataMessageStanza::set_allocated_from(::std::string* from) {
  if (from != NULL) {
    set_has_from();
  } else {
    clear_has_from();
  }
  from_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from);
  // @@protoc_insertion_point(field_set_allocated:mcs_proto.DataMessageStanza.from)
}

// optional string to = 4;
inline bool DataMessageStanza::has_to() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DataMessageStanza::set_has_to() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DataMessageStanza::clear_has_to() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DataMessageStanza::clear_to() {
  to_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_to();
}
inline const ::std::string& DataMessageStanza::to() const {
  // @@protoc_insertion_point(field_get:mcs_proto.DataMessageStanza.to)
  return to_.GetNoArena();
}
inline void DataMessageStanza::set_to(const ::std::string& value) {
  set_has_to();
  to_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcs_proto.DataMessageStanza.to)
}
#if LANG_CXX11
inline void DataMessageStanza::set_to(::std::string&& value) {
  set_has_to();
  to_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcs_proto.DataMessageStanza.to)
}
#endif
inline void DataMessageStanza::set_to(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_to();
  to_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcs_proto.DataMessageStanza.to)
}
inline void DataMessageStanza::set_to(const char* value, size_t size) {
  set_has_to();
  to_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcs_proto.DataMessageStanza.to)
}
inline ::std::string* DataMessageStanza::mutable_to() {
  set_has_to();
  // @@protoc_insertion_point(field_mutable:mcs_proto.DataMessageStanza.to)
  return to_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DataMessageStanza::release_to() {
  // @@protoc_insertion_point(field_release:mcs_proto.DataMessageStanza.to)
  clear_has_to();
  return to_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DataMessageStanza::set_allocated_to(::std::string* to) {
  if (to != NULL) {
    set_has_to();
  } else {
    clear_has_to();
  }
  to_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), to);
  // @@protoc_insertion_point(field_set_allocated:mcs_proto.DataMessageStanza.to)
}

// required string category = 5;
inline bool DataMessageStanza::has_category() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DataMessageStanza::set_has_category() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DataMessageStanza::clear_has_category() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DataMessageStanza::clear_category() {
  category_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_category();
}
inline const ::std::string& DataMessageStanza::category() const {
  // @@protoc_insertion_point(field_get:mcs_proto.DataMessageStanza.category)
  return category_.GetNoArena();
}
inline void DataMessageStanza::set_category(const ::std::string& value) {
  set_has_category();
  category_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcs_proto.DataMessageStanza.category)
}
#if LANG_CXX11
inline void DataMessageStanza::set_category(::std::string&& value) {
  set_has_category();
  category_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcs_proto.DataMessageStanza.category)
}
#endif
inline void DataMessageStanza::set_category(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_category();
  category_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcs_proto.DataMessageStanza.category)
}
inline void DataMessageStanza::set_category(const char* value, size_t size) {
  set_has_category();
  category_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcs_proto.DataMessageStanza.category)
}
inline ::std::string* DataMessageStanza::mutable_category() {
  set_has_category();
  // @@protoc_insertion_point(field_mutable:mcs_proto.DataMessageStanza.category)
  return category_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DataMessageStanza::release_category() {
  // @@protoc_insertion_point(field_release:mcs_proto.DataMessageStanza.category)
  clear_has_category();
  return category_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DataMessageStanza::set_allocated_category(::std::string* category) {
  if (category != NULL) {
    set_has_category();
  } else {
    clear_has_category();
  }
  category_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), category);
  // @@protoc_insertion_point(field_set_allocated:mcs_proto.DataMessageStanza.category)
}

// optional string token = 6;
inline bool DataMessageStanza::has_token() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DataMessageStanza::set_has_token() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DataMessageStanza::clear_has_token() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DataMessageStanza::clear_token() {
  token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_token();
}
inline const ::std::string& DataMessageStanza::token() const {
  // @@protoc_insertion_point(field_get:mcs_proto.DataMessageStanza.token)
  return token_.GetNoArena();
}
inline void DataMessageStanza::set_token(const ::std::string& value) {
  set_has_token();
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcs_proto.DataMessageStanza.token)
}
#if LANG_CXX11
inline void DataMessageStanza::set_token(::std::string&& value) {
  set_has_token();
  token_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcs_proto.DataMessageStanza.token)
}
#endif
inline void DataMessageStanza::set_token(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_token();
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcs_proto.DataMessageStanza.token)
}
inline void DataMessageStanza::set_token(const char* value, size_t size) {
  set_has_token();
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcs_proto.DataMessageStanza.token)
}
inline ::std::string* DataMessageStanza::mutable_token() {
  set_has_token();
  // @@protoc_insertion_point(field_mutable:mcs_proto.DataMessageStanza.token)
  return token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DataMessageStanza::release_token() {
  // @@protoc_insertion_point(field_release:mcs_proto.DataMessageStanza.token)
  clear_has_token();
  return token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DataMessageStanza::set_allocated_token(::std::string* token) {
  if (token != NULL) {
    set_has_token();
  } else {
    clear_has_token();
  }
  token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), token);
  // @@protoc_insertion_point(field_set_allocated:mcs_proto.DataMessageStanza.token)
}

// repeated .mcs_proto.AppData app_data = 7;
inline int DataMessageStanza::app_data_size() const {
  return app_data_.size();
}
inline void DataMessageStanza::clear_app_data() {
  app_data_.Clear();
}
inline const ::mcs_proto::AppData& DataMessageStanza::app_data(int index) const {
  // @@protoc_insertion_point(field_get:mcs_proto.DataMessageStanza.app_data)
  return app_data_.Get(index);
}
inline ::mcs_proto::AppData* DataMessageStanza::mutable_app_data(int index) {
  // @@protoc_insertion_point(field_mutable:mcs_proto.DataMessageStanza.app_data)
  return app_data_.Mutable(index);
}
inline ::mcs_proto::AppData* DataMessageStanza::add_app_data() {
  // @@protoc_insertion_point(field_add:mcs_proto.DataMessageStanza.app_data)
  return app_data_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mcs_proto::AppData >*
DataMessageStanza::mutable_app_data() {
  // @@protoc_insertion_point(field_mutable_list:mcs_proto.DataMessageStanza.app_data)
  return &app_data_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mcs_proto::AppData >&
DataMessageStanza::app_data() const {
  // @@protoc_insertion_point(field_list:mcs_proto.DataMessageStanza.app_data)
  return app_data_;
}

// optional bool from_trusted_server = 8;
inline bool DataMessageStanza::has_from_trusted_server() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void DataMessageStanza::set_has_from_trusted_server() {
  _has_bits_[0] |= 0x00000800u;
}
inline void DataMessageStanza::clear_has_from_trusted_server() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void DataMessageStanza::clear_from_trusted_server() {
  from_trusted_server_ = false;
  clear_has_from_trusted_server();
}
inline bool DataMessageStanza::from_trusted_server() const {
  // @@protoc_insertion_point(field_get:mcs_proto.DataMessageStanza.from_trusted_server)
  return from_trusted_server_;
}
inline void DataMessageStanza::set_from_trusted_server(bool value) {
  set_has_from_trusted_server();
  from_trusted_server_ = value;
  // @@protoc_insertion_point(field_set:mcs_proto.DataMessageStanza.from_trusted_server)
}

// optional string persistent_id = 9;
inline bool DataMessageStanza::has_persistent_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DataMessageStanza::set_has_persistent_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DataMessageStanza::clear_has_persistent_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DataMessageStanza::clear_persistent_id() {
  persistent_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_persistent_id();
}
inline const ::std::string& DataMessageStanza::persistent_id() const {
  // @@protoc_insertion_point(field_get:mcs_proto.DataMessageStanza.persistent_id)
  return persistent_id_.GetNoArena();
}
inline void DataMessageStanza::set_persistent_id(const ::std::string& value) {
  set_has_persistent_id();
  persistent_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcs_proto.DataMessageStanza.persistent_id)
}
#if LANG_CXX11
inline void DataMessageStanza::set_persistent_id(::std::string&& value) {
  set_has_persistent_id();
  persistent_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcs_proto.DataMessageStanza.persistent_id)
}
#endif
inline void DataMessageStanza::set_persistent_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_persistent_id();
  persistent_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcs_proto.DataMessageStanza.persistent_id)
}
inline void DataMessageStanza::set_persistent_id(const char* value, size_t size) {
  set_has_persistent_id();
  persistent_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcs_proto.DataMessageStanza.persistent_id)
}
inline ::std::string* DataMessageStanza::mutable_persistent_id() {
  set_has_persistent_id();
  // @@protoc_insertion_point(field_mutable:mcs_proto.DataMessageStanza.persistent_id)
  return persistent_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DataMessageStanza::release_persistent_id() {
  // @@protoc_insertion_point(field_release:mcs_proto.DataMessageStanza.persistent_id)
  clear_has_persistent_id();
  return persistent_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DataMessageStanza::set_allocated_persistent_id(::std::string* persistent_id) {
  if (persistent_id != NULL) {
    set_has_persistent_id();
  } else {
    clear_has_persistent_id();
  }
  persistent_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), persistent_id);
  // @@protoc_insertion_point(field_set_allocated:mcs_proto.DataMessageStanza.persistent_id)
}

// optional int32 stream_id = 10;
inline bool DataMessageStanza::has_stream_id() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DataMessageStanza::set_has_stream_id() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DataMessageStanza::clear_has_stream_id() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DataMessageStanza::clear_stream_id() {
  stream_id_ = 0;
  clear_has_stream_id();
}
inline ::google::protobuf::int32 DataMessageStanza::stream_id() const {
  // @@protoc_insertion_point(field_get:mcs_proto.DataMessageStanza.stream_id)
  return stream_id_;
}
inline void DataMessageStanza::set_stream_id(::google::protobuf::int32 value) {
  set_has_stream_id();
  stream_id_ = value;
  // @@protoc_insertion_point(field_set:mcs_proto.DataMessageStanza.stream_id)
}

// optional int32 last_stream_id_received = 11;
inline bool DataMessageStanza::has_last_stream_id_received() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DataMessageStanza::set_has_last_stream_id_received() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DataMessageStanza::clear_has_last_stream_id_received() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DataMessageStanza::clear_last_stream_id_received() {
  last_stream_id_received_ = 0;
  clear_has_last_stream_id_received();
}
inline ::google::protobuf::int32 DataMessageStanza::last_stream_id_received() const {
  // @@protoc_insertion_point(field_get:mcs_proto.DataMessageStanza.last_stream_id_received)
  return last_stream_id_received_;
}
inline void DataMessageStanza::set_last_stream_id_received(::google::protobuf::int32 value) {
  set_has_last_stream_id_received();
  last_stream_id_received_ = value;
  // @@protoc_insertion_point(field_set:mcs_proto.DataMessageStanza.last_stream_id_received)
}

// optional string reg_id = 13;
inline bool DataMessageStanza::has_reg_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DataMessageStanza::set_has_reg_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DataMessageStanza::clear_has_reg_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DataMessageStanza::clear_reg_id() {
  reg_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_reg_id();
}
inline const ::std::string& DataMessageStanza::reg_id() const {
  // @@protoc_insertion_point(field_get:mcs_proto.DataMessageStanza.reg_id)
  return reg_id_.GetNoArena();
}
inline void DataMessageStanza::set_reg_id(const ::std::string& value) {
  set_has_reg_id();
  reg_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcs_proto.DataMessageStanza.reg_id)
}
#if LANG_CXX11
inline void DataMessageStanza::set_reg_id(::std::string&& value) {
  set_has_reg_id();
  reg_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcs_proto.DataMessageStanza.reg_id)
}
#endif
inline void DataMessageStanza::set_reg_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_reg_id();
  reg_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcs_proto.DataMessageStanza.reg_id)
}
inline void DataMessageStanza::set_reg_id(const char* value, size_t size) {
  set_has_reg_id();
  reg_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcs_proto.DataMessageStanza.reg_id)
}
inline ::std::string* DataMessageStanza::mutable_reg_id() {
  set_has_reg_id();
  // @@protoc_insertion_point(field_mutable:mcs_proto.DataMessageStanza.reg_id)
  return reg_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DataMessageStanza::release_reg_id() {
  // @@protoc_insertion_point(field_release:mcs_proto.DataMessageStanza.reg_id)
  clear_has_reg_id();
  return reg_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DataMessageStanza::set_allocated_reg_id(::std::string* reg_id) {
  if (reg_id != NULL) {
    set_has_reg_id();
  } else {
    clear_has_reg_id();
  }
  reg_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), reg_id);
  // @@protoc_insertion_point(field_set_allocated:mcs_proto.DataMessageStanza.reg_id)
}

// optional int64 device_user_id = 16;
inline bool DataMessageStanza::has_device_user_id() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void DataMessageStanza::set_has_device_user_id() {
  _has_bits_[0] |= 0x00000400u;
}
inline void DataMessageStanza::clear_has_device_user_id() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void DataMessageStanza::clear_device_user_id() {
  device_user_id_ = GOOGLE_LONGLONG(0);
  clear_has_device_user_id();
}
inline ::google::protobuf::int64 DataMessageStanza::device_user_id() const {
  // @@protoc_insertion_point(field_get:mcs_proto.DataMessageStanza.device_user_id)
  return device_user_id_;
}
inline void DataMessageStanza::set_device_user_id(::google::protobuf::int64 value) {
  set_has_device_user_id();
  device_user_id_ = value;
  // @@protoc_insertion_point(field_set:mcs_proto.DataMessageStanza.device_user_id)
}

// optional int32 ttl = 17;
inline bool DataMessageStanza::has_ttl() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void DataMessageStanza::set_has_ttl() {
  _has_bits_[0] |= 0x00002000u;
}
inline void DataMessageStanza::clear_has_ttl() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void DataMessageStanza::clear_ttl() {
  ttl_ = 0;
  clear_has_ttl();
}
inline ::google::protobuf::int32 DataMessageStanza::ttl() const {
  // @@protoc_insertion_point(field_get:mcs_proto.DataMessageStanza.ttl)
  return ttl_;
}
inline void DataMessageStanza::set_ttl(::google::protobuf::int32 value) {
  set_has_ttl();
  ttl_ = value;
  // @@protoc_insertion_point(field_set:mcs_proto.DataMessageStanza.ttl)
}

// optional int64 sent = 18;
inline bool DataMessageStanza::has_sent() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void DataMessageStanza::set_has_sent() {
  _has_bits_[0] |= 0x00004000u;
}
inline void DataMessageStanza::clear_has_sent() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void DataMessageStanza::clear_sent() {
  sent_ = GOOGLE_LONGLONG(0);
  clear_has_sent();
}
inline ::google::protobuf::int64 DataMessageStanza::sent() const {
  // @@protoc_insertion_point(field_get:mcs_proto.DataMessageStanza.sent)
  return sent_;
}
inline void DataMessageStanza::set_sent(::google::protobuf::int64 value) {
  set_has_sent();
  sent_ = value;
  // @@protoc_insertion_point(field_set:mcs_proto.DataMessageStanza.sent)
}

// optional int32 queued = 19;
inline bool DataMessageStanza::has_queued() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void DataMessageStanza::set_has_queued() {
  _has_bits_[0] |= 0x00008000u;
}
inline void DataMessageStanza::clear_has_queued() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void DataMessageStanza::clear_queued() {
  queued_ = 0;
  clear_has_queued();
}
inline ::google::protobuf::int32 DataMessageStanza::queued() const {
  // @@protoc_insertion_point(field_get:mcs_proto.DataMessageStanza.queued)
  return queued_;
}
inline void DataMessageStanza::set_queued(::google::protobuf::int32 value) {
  set_has_queued();
  queued_ = value;
  // @@protoc_insertion_point(field_set:mcs_proto.DataMessageStanza.queued)
}

// optional int64 status = 20;
inline bool DataMessageStanza::has_status() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void DataMessageStanza::set_has_status() {
  _has_bits_[0] |= 0x00010000u;
}
inline void DataMessageStanza::clear_has_status() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void DataMessageStanza::clear_status() {
  status_ = GOOGLE_LONGLONG(0);
  clear_has_status();
}
inline ::google::protobuf::int64 DataMessageStanza::status() const {
  // @@protoc_insertion_point(field_get:mcs_proto.DataMessageStanza.status)
  return status_;
}
inline void DataMessageStanza::set_status(::google::protobuf::int64 value) {
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:mcs_proto.DataMessageStanza.status)
}

// optional bytes raw_data = 21;
inline bool DataMessageStanza::has_raw_data() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DataMessageStanza::set_has_raw_data() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DataMessageStanza::clear_has_raw_data() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DataMessageStanza::clear_raw_data() {
  raw_data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_raw_data();
}
inline const ::std::string& DataMessageStanza::raw_data() const {
  // @@protoc_insertion_point(field_get:mcs_proto.DataMessageStanza.raw_data)
  return raw_data_.GetNoArena();
}
inline void DataMessageStanza::set_raw_data(const ::std::string& value) {
  set_has_raw_data();
  raw_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mcs_proto.DataMessageStanza.raw_data)
}
#if LANG_CXX11
inline void DataMessageStanza::set_raw_data(::std::string&& value) {
  set_has_raw_data();
  raw_data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mcs_proto.DataMessageStanza.raw_data)
}
#endif
inline void DataMessageStanza::set_raw_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_raw_data();
  raw_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mcs_proto.DataMessageStanza.raw_data)
}
inline void DataMessageStanza::set_raw_data(const void* value, size_t size) {
  set_has_raw_data();
  raw_data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mcs_proto.DataMessageStanza.raw_data)
}
inline ::std::string* DataMessageStanza::mutable_raw_data() {
  set_has_raw_data();
  // @@protoc_insertion_point(field_mutable:mcs_proto.DataMessageStanza.raw_data)
  return raw_data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DataMessageStanza::release_raw_data() {
  // @@protoc_insertion_point(field_release:mcs_proto.DataMessageStanza.raw_data)
  clear_has_raw_data();
  return raw_data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DataMessageStanza::set_allocated_raw_data(::std::string* raw_data) {
  if (raw_data != NULL) {
    set_has_raw_data();
  } else {
    clear_has_raw_data();
  }
  raw_data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), raw_data);
  // @@protoc_insertion_point(field_set_allocated:mcs_proto.DataMessageStanza.raw_data)
}

// optional bool immediate_ack = 24;
inline bool DataMessageStanza::has_immediate_ack() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void DataMessageStanza::set_has_immediate_ack() {
  _has_bits_[0] |= 0x00001000u;
}
inline void DataMessageStanza::clear_has_immediate_ack() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void DataMessageStanza::clear_immediate_ack() {
  immediate_ack_ = false;
  clear_has_immediate_ack();
}
inline bool DataMessageStanza::immediate_ack() const {
  // @@protoc_insertion_point(field_get:mcs_proto.DataMessageStanza.immediate_ack)
  return immediate_ack_;
}
inline void DataMessageStanza::set_immediate_ack(bool value) {
  set_has_immediate_ack();
  immediate_ack_ = value;
  // @@protoc_insertion_point(field_set:mcs_proto.DataMessageStanza.immediate_ack)
}

// -------------------------------------------------------------------

// StreamAck

// -------------------------------------------------------------------

// SelectiveAck

// repeated string id = 1;
inline int SelectiveAck::id_size() const {
  return id_.size();
}
inline void SelectiveAck::clear_id() {
  id_.Clear();
}
inline const ::std::string& SelectiveAck::id(int index) const {
  // @@protoc_insertion_point(field_get:mcs_proto.SelectiveAck.id)
  return id_.Get(index);
}
inline ::std::string* SelectiveAck::mutable_id(int index) {
  // @@protoc_insertion_point(field_mutable:mcs_proto.SelectiveAck.id)
  return id_.Mutable(index);
}
inline void SelectiveAck::set_id(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:mcs_proto.SelectiveAck.id)
  id_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void SelectiveAck::set_id(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:mcs_proto.SelectiveAck.id)
  id_.Mutable(index)->assign(std::move(value));
}
#endif
inline void SelectiveAck::set_id(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  id_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mcs_proto.SelectiveAck.id)
}
inline void SelectiveAck::set_id(int index, const char* value, size_t size) {
  id_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mcs_proto.SelectiveAck.id)
}
inline ::std::string* SelectiveAck::add_id() {
  // @@protoc_insertion_point(field_add_mutable:mcs_proto.SelectiveAck.id)
  return id_.Add();
}
inline void SelectiveAck::add_id(const ::std::string& value) {
  id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:mcs_proto.SelectiveAck.id)
}
#if LANG_CXX11
inline void SelectiveAck::add_id(::std::string&& value) {
  id_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:mcs_proto.SelectiveAck.id)
}
#endif
inline void SelectiveAck::add_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  id_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mcs_proto.SelectiveAck.id)
}
inline void SelectiveAck::add_id(const char* value, size_t size) {
  id_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mcs_proto.SelectiveAck.id)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SelectiveAck::id() const {
  // @@protoc_insertion_point(field_list:mcs_proto.SelectiveAck.id)
  return id_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SelectiveAck::mutable_id() {
  // @@protoc_insertion_point(field_mutable_list:mcs_proto.SelectiveAck.id)
  return &id_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace mcs_proto

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::mcs_proto::ClientEvent_Type> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::mcs_proto::LoginRequest_AuthService> : ::google::protobuf::internal::true_type {};
template <> struct is_proto_enum< ::mcs_proto::IqStanza_IqType> : ::google::protobuf::internal::true_type {};

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_mcs_2eproto__INCLUDED
